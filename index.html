<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Neon Survivor v5.0 - AWAKENING</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --neon-blue: #00f3ff;
            --neon-pink: #ff00ff;
            --neon-gold: #ffd700;
            --neon-red: #ff3333;
            --bg-color: #050505;
        }
        body {
            margin: 0; overflow: hidden; background-color: var(--bg-color);
            font-family: 'Rajdhani', sans-serif; color: white; user-select: none;
        }
        canvas { display: block; }

        /* UI ÈÄöÁî® */
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(5, 5, 8, 0.92);
            backdrop-filter: blur(12px);
            z-index: 100; transition: opacity 0.3s;
        }
        .hidden { opacity: 0; pointer-events: none; }
        
        h1 {
            font-family: 'Orbitron', sans-serif; font-size: 80px; margin: 0;
            background: linear-gradient(to right, var(--neon-blue), var(--neon-pink));
            -webkit-background-clip: text; color: transparent;
            text-shadow: 0 0 30px rgba(0, 243, 255, 0.4);
            letter-spacing: 5px;
        }
        
        /* ËßâÈÜíÁâπÊïàÊñáÂ≠ó */
        .awakened-text {
            color: var(--neon-gold) !important;
            text-shadow: 0 0 20px var(--neon-gold), 0 0 40px red !important;
            animation: pulse-gold 0.5s infinite alternate;
        }
        @keyframes pulse-gold { from { transform: scale(1); } to { transform: scale(1.1); } }

        button {
            background: transparent; color: white; border: 2px solid var(--neon-blue);
            padding: 15px 50px; font-family: 'Orbitron'; font-size: 24px; font-weight: bold;
            margin-top: 30px; cursor: pointer; transition: 0.2s;
            box-shadow: 0 0 15px var(--neon-blue); text-transform: uppercase;
            clip-path: polygon(15px 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%, 0 15px);
        }
        button:hover {
            background: var(--neon-blue); color: black; box-shadow: 0 0 40px var(--neon-blue);
            transform: scale(1.05);
        }

        /* HUD */
        #hud-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .exp-bar-box {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            width: 50%; height: 20px; background: #111; border: 1px solid #444;
            transform: skewX(-20deg);
        }
        .exp-fill {
            height: 100%; width: 0%; background: linear-gradient(90deg, var(--neon-blue), var(--neon-pink));
            box-shadow: 0 0 15px var(--neon-blue); transition: width 0.2s;
        }
        .stat-display {
            position: absolute; top: 40px; left: 20px;
            font-family: 'Orbitron'; font-size: 14px; color: #888;
        }
        .timer-display {
            position: absolute; top: 20px; right: 20px;
            font-family: 'Orbitron'; font-size: 32px; color: white;
        }

        /* ÂçáÁ∫ßÂç°ÁâáÁ≥ªÁªü */
        .cards-wrapper { display: flex; gap: 20px; margin-top: 20px; }
        .card {
            width: 200px; height: 300px;
            background: linear-gradient(160deg, #15151a, #0a0a0c);
            border: 1px solid #444; border-top: 4px solid var(--c);
            border-radius: 8px; padding: 15px; cursor: pointer;
            display: flex; flex-direction: column; align-items: center; text-align: center;
            transition: 0.3s; position: relative; overflow: hidden;
        }
        .card:hover { transform: translateY(-15px) scale(1.02); border-color: var(--c); box-shadow: 0 0 30px var(--c); }
        .card-icon { font-size: 50px; margin: 20px 0; filter: drop-shadow(0 0 10px var(--c)); }
        .card h3 { color: var(--c); margin: 0 0 5px 0; font-family: 'Orbitron'; font-size: 18px; }
        .card .lvl-badge { 
            background: #222; padding: 2px 8px; border-radius: 4px; font-size: 12px; margin-bottom: 10px; 
            border: 1px solid #444; color: #aaa;
        }
        .card.is-awakening {
            background: linear-gradient(160deg, #330000, #110000);
            border-color: var(--neon-gold);
            animation: border-pulse 1s infinite alternate;
        }
        .card.is-awakening h3 { color: var(--neon-gold); }
        .card.is-awakening .lvl-badge { background: var(--neon-gold); color: black; font-weight: bold; }
        
        @keyframes border-pulse { from { box-shadow: 0 0 10px var(--neon-gold); } to { box-shadow: 0 0 30px var(--neon-gold), 0 0 10px red; } }

        /* ËßâÈÜíÊèêÁ§∫Ê®™ÂπÖ */
        #awakening-banner {
            position: absolute; top: 30%; width: 100%; text-align: center;
            font-family: 'Orbitron'; font-size: 60px; font-weight: 900;
            color: var(--neon-gold); text-shadow: 0 0 50px red;
            pointer-events: none; opacity: 0; transform: scale(2);
            transition: 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        #awakening-banner.show { opacity: 1; transform: scale(1); }
        
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    
    <div id="awakening-banner">ULTIMATE AWAKENED!</div>

    <div id="upgrade-screen" class="overlay hidden">
        <h2 style="font-family:'Orbitron'; font-size:40px; color:white;">SYSTEM UPGRADE</h2>
        <div class="cards-wrapper" id="cards-container"></div>
        <button onclick="reroll()" style="margin-top:40px; font-size:16px; padding:10px 30px; border-color:#666; color:#aaa;">REROLL</button>
    </div>

    <div id="start-screen" class="overlay">
        <h1>NEON SURVIVOR</h1>
        <div style="color:var(--neon-gold); margin-bottom: 20px; font-family: 'Orbitron';">v5.0 AWAKENING UPDATE</div>
        <button onclick="startGame()">INITIATE</button>
    </div>

    <div id="hud-layer" class="hidden">
        <div class="exp-bar-box"><div class="exp-fill" id="exp-bar"></div></div>
        <div class="timer-display" id="timer">00:00</div>
        <div class="stat-display" id="stats-debug"></div>
    </div>

    <div id="game-over" class="overlay hidden">
        <h1 style="color:var(--neon-red);">TERMINATED</h1>
        <p id="final-score" style="font-size:24px; color:#ccc;">...</p>
        <button onclick="location.reload()">REBOOT</button>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // ÂÖ®Â±ÄÈÖçËâ≤
    const C = {
        bullet: '#00f3ff',
        bullet_god: '#ffd700', // ËßâÈÜíÂ≠êÂºπÈ¢úËâ≤
        enemy: '#ff0055',
        exp: '#00ff66',
        blackhole: '#a020f0',
        blackhole_god: '#ff0000', // ËßâÈÜíÈªëÊ¥û
        shield: '#00ccff',
        shield_god: '#ffaa00'
    };

    let state = 'start'; // start, running, upgrade, gameover
    let frame = 0;
    let bgOffset = {x:0, y:0};
    
    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize); resize();

    // --- Áé©ÂÆ∂Á±ª ---
    class Player {
        constructor() {
            this.x = canvas.width/2; this.y = canvas.height/2;
            this.hp = 100; this.maxHp = 100;
            this.level = 1; this.exp = 0; this.nextExp = 15;
            this.kills = 0;
            this.speed = 4;
            
            // ÊäÄËÉΩÁ≠âÁ∫ßËøΩË∏™
            this.levels = {
                shot: 1,      // Âü∫Á°ÄÂ∞ÑÂáª
                guardian: 0,  // Êä§Áõæ
                blackhole: 0, // ÈªëÊ¥û
                mines: 0      // Âú∞Èõ∑
            };

            // ËßâÈÜíÁä∂ÊÄÅ (Lv 5)
            this.awakened = {
                shot: false,
                guardian: false,
                blackhole: false,
                mines: false
            };
            
            this.timers = { shot: 0, guardian: 0, blackhole: 0, mine: 0 };
            this.guardianAngle = 0;
        }

        update() {
            // ÁßªÂä®
            let dx=0, dy=0;
            if(keys['w']) dy-=1; if(keys['s']) dy+=1;
            if(keys['a']) dx-=1; if(keys['d']) dx+=1;
            if(dx||dy) {
                const l = Math.hypot(dx, dy);
                this.x += (dx/l)*this.speed; this.y += (dy/l)*this.speed;
                bgOffset.x -= (dx/l)*this.speed*0.5; bgOffset.y -= (dy/l)*this.speed*0.5;
            }
            this.x = Math.max(20, Math.min(canvas.width-20, this.x));
            this.y = Math.max(20, Math.min(canvas.height-20, this.y));

            // --- ÊäÄËÉΩÈÄªËæë ---

            // 1. Â∞ÑÂáª (Multishot)
            // ËßâÈÜí: "GOD SLAYER" - Â∞ÑÈÄüÊûÅÂø´ÔºåÁ©øÈÄèÔºåÁ∫¢Ëâ≤ÊøÄÂÖâ
            if(this.timers.shot > 0) this.timers.shot--;
            else {
                const target = findNearest(this.x, this.y);
                if(target) {
                    const isGod = this.awakened.shot;
                    const count = this.levels.shot + (isGod ? 4 : 0); // ËßâÈÜí+4Âèë
                    const dmg = 15 + this.levels.shot * 5 + (isGod ? 30 : 0);
                    const spread = isGod ? 0.4 : 0.2;
                    
                    const angle = Math.atan2(target.y - this.y, target.x - this.x);
                    const startA = angle - (spread * (count-1))/2;
                    
                    for(let i=0; i<count; i++) {
                        const a = startA + i * spread;
                        bullets.push(new Bullet(this.x, this.y, Math.cos(a)*12, Math.sin(a)*12, dmg, isGod));
                    }
                    this.timers.shot = isGod ? 15 : Math.max(5, 35 - this.levels.shot * 2);
                    // ËßâÈÜíÂ∞ÑÂáªÁâπÊïà
                    if(isGod) spawnParticles(this.x, this.y, C.bullet_god, 5);
                }
            }

            // 2. Êä§Áõæ (Guardian)
            // ËßâÈÜí: "ION STORM" - Êï∞ÈáèÁøªÂÄçÔºåËΩ¨ÈÄüÊûÅÂø´ÔºåËåÉÂõ¥ÂèòÂ§ß
            if(this.levels.guardian > 0) {
                const isGod = this.awakened.guardian;
                const orbCount = this.levels.guardian + (isGod ? 5 : 0);
                const speed = isGod ? 0.15 : 0.05;
                const dist = isGod ? 120 : 80;
                
                this.guardianAngle += speed;
                for(let i=0; i<orbCount; i++) {
                    const a = this.guardianAngle + (Math.PI*2/orbCount)*i;
                    const gx = this.x + Math.cos(a)*dist;
                    const gy = this.y + Math.sin(a)*dist;
                    
                    // ‰º§ÂÆ≥ÈÄªËæë (ÁÆÄÂåñÔºåÁõ¥Êé•ÈÅçÂéÜÊïå‰∫∫)
                    enemies.forEach(e => {
                        if(Math.hypot(e.x-gx, e.y-gy) < (isGod?25:15)) {
                            e.hit(isGod ? 5 : 2); // ËßâÈÜí‰º§ÂÆ≥È´ò
                            if(frame % 5 === 0) spawnParticles(e.x, e.y, isGod ? C.shield_god : C.shield, 1);
                        }
                    });
                    
                    // ÁªòÂà∂ (Âú®updateÈáåÁîªÊòØ‰∏∫‰∫ÜÊñπ‰æøÔºåÂÆûÈôÖ‰∏äÂ∫îËØ•Âú®draw)
                    // ‰ΩÜ‰∏∫‰∫Ü‰øùÊåÅÁ≤íÂ≠êÁã¨Á´ãÔºåÊàë‰ª¨ËøôÈáåÂè™ÂÅöÈÄªËæëÔºådrawÈáå‰∏ìÈó®Áîª
                }
            }

            // 3. ÈªëÊ¥û (Singularity)
            // ËßâÈÜí: "EVENT HORIZON" - Á∫¢Ëâ≤ÈªëÊ¥ûÔºåÂÖ®Â±èÂê∏ÈôÑÔºåÂ∑®È¢ù‰º§ÂÆ≥
            if(this.levels.blackhole > 0) {
                if(this.timers.blackhole > 0) this.timers.blackhole--;
                else {
                    const isGod = this.awakened.blackhole;
                    // ËßâÈÜíÈªëÊ¥ûÁîüÊàêÂú®ÈöèÊú∫Êïå‰∫∫ËÑö‰∏ã
                    let tx = this.x, ty = this.y;
                    const t = findNearest(this.x, this.y);
                    if(t) { tx = t.x; ty = t.y; }
                    else {
                        const a = Math.random()*Math.PI*2;
                        tx += Math.cos(a)*150; ty += Math.sin(a)*150;
                    }
                    
                    objs.push(new BlackHole(tx, ty, this.levels.blackhole, isGod));
                    this.timers.blackhole = isGod ? 240 : 360; // ËßâÈÜíCDÊõ¥Áü≠
                }
            }
        }

        draw() {
            // Áé©ÂÆ∂Êú¨‰Ωì
            ctx.shadowBlur = 20; ctx.shadowColor = this.awakened.shot ? C.bullet_god : C.bullet;
            ctx.fillStyle = 'white';
            ctx.beginPath(); ctx.arc(this.x, this.y, 12, 0, Math.PI*2); ctx.fill();
            
            // ÁªòÂà∂Êä§Áõæ
            if(this.levels.guardian > 0) {
                const isGod = this.awakened.guardian;
                const orbCount = this.levels.guardian + (isGod ? 5 : 0);
                const dist = isGod ? 120 : 80;
                const col = isGod ? C.shield_god : C.shield;
                
                ctx.shadowColor = col;
                ctx.fillStyle = col;
                for(let i=0; i<orbCount; i++) {
                    const a = this.guardianAngle + (Math.PI*2/orbCount)*i;
                    ctx.beginPath();
                    ctx.arc(this.x + Math.cos(a)*dist, this.y + Math.sin(a)*dist, isGod?10:6, 0, Math.PI*2);
                    ctx.fill();
                    // ËßâÈÜíÊä§ÁõæËøûÁ∫ø
                    if(isGod) {
                        ctx.strokeStyle = col; ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.moveTo(this.x, this.y); 
                        ctx.lineTo(this.x + Math.cos(a)*dist, this.y + Math.sin(a)*dist);
                        ctx.stroke();
                    }
                }
            }
            ctx.shadowBlur = 0;
        }

        gainExp(v) {
            this.exp += v;
            if(this.exp >= this.nextExp) {
                this.exp -= this.nextExp;
                this.level++;
                this.nextExp = Math.floor(this.nextExp * 1.4);
                openUpgradeMenu();
            }
            updateHUD();
        }
    }

    // --- Áâ©ÂìÅÁ±ª ---
    class Bullet {
        constructor(x, y, vx, vy, dmg, isGod) {
            this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.dmg=dmg; this.isGod=isGod;
            this.life = 60;
            this.color = isGod ? C.bullet_god : C.bullet;
        }
        update() {
            this.x+=this.vx; this.y+=this.vy; this.life--;
            // ËßâÈÜíÂ≠êÂºπÊúâÂ∞æËøπ
            if(this.isGod && frame%2===0) spawnParticles(this.x, this.y, this.color, 1);
            
            enemies.forEach(e => {
                if(Math.hypot(e.x-this.x, e.y-this.y) < e.r+10) {
                    e.hit(this.dmg);
                    if(!this.isGod) this.life = 0; // ËßâÈÜíÂ≠êÂºπÁ©øÈÄè
                    else {
                        // ËßâÈÜíÂ≠êÂºπÂáª‰∏≠ÁâπÊïà
                        spawnParticles(this.x, this.y, C.bullet_god, 3);
                        screenShake = 2;
                    }
                }
            });
        }
        draw() {
            ctx.fillStyle = this.color;
            ctx.shadowBlur = 10; ctx.shadowColor = this.color;
            ctx.beginPath(); 
            if(this.isGod) ctx.arc(this.x, this.y, 6, 0, Math.PI*2);
            else ctx.arc(this.x, this.y, 4, 0, Math.PI*2); 
            ctx.fill();
            ctx.shadowBlur = 0;
        }
    }

    class BlackHole {
        constructor(x, y, lvl, isGod) {
            this.x=x; this.y=y; this.isGod=isGod;
            this.life = 300; 
            this.range = 150 + lvl*20 + (isGod?150:0);
            this.angle = 0;
            this.color = isGod ? C.blackhole_god : C.blackhole;
        }
        update() {
            this.life--; this.angle += 0.1;
            if(this.isGod) { 
                this.range = 300 + Math.sin(frame*0.1)*50; // ÂëºÂê∏ÊïàÊûú
                screenShake = 1;
            }
            
            enemies.forEach(e => {
                const d = Math.hypot(e.x-this.x, e.y-this.y);
                if(d < this.range) {
                    const pull = this.isGod ? 5 : 2; // Âê∏Âäõ
                    const a = Math.atan2(this.y-e.y, this.x-e.x);
                    e.x += Math.cos(a)*pull; e.y += Math.sin(a)*pull;
                    e.hit(this.isGod ? 1.5 : 0.5); // ÊåÅÁª≠‰º§ÂÆ≥
                }
            });
        }
        draw() {
            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
            ctx.strokeStyle = this.color; ctx.lineWidth = this.isGod?5:2;
            ctx.beginPath(); 
            // ÁªòÂà∂ÊóãÊ∂°
            for(let i=0; i<4; i++) {
                ctx.rotate(Math.PI/2);
                ctx.moveTo(10,0); ctx.lineTo(this.range*(this.isGod?0.8:0.5), 0);
            }
            ctx.stroke();
            // ‰∏≠ÂøÉ
            ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(0,0,20,0,Math.PI*2); ctx.fill();
            ctx.strokeStyle='white'; ctx.lineWidth=1; ctx.stroke();
            // ËßÜÁïå
            ctx.beginPath(); ctx.arc(0,0,this.range,0,Math.PI*2); 
            ctx.strokeStyle = `rgba(${this.isGod?'255,0,0':'160,32,240'}, 0.2)`; 
            ctx.stroke();
            ctx.restore();
        }
    }

    class Enemy {
        constructor() {
            const a = Math.random()*Math.PI*2;
            const d = Math.max(canvas.width, canvas.height)*0.7;
            this.x = player.x+Math.cos(a)*d; this.y = player.y+Math.sin(a)*d;
            this.hp = 20 + player.level*5; this.maxHp = this.hp;
            this.speed = 1 + Math.random();
            this.r = 15;
            this.color = C.enemy;
        }
        update() {
            const a = Math.atan2(player.y-this.y, player.x-this.x);
            this.x += Math.cos(a)*this.speed; this.y += Math.sin(a)*this.speed;
            
            if(Math.hypot(player.x-this.x, player.y-this.y) < this.r+10) {
                player.hp -= 0.5; updateHUD();
                if(player.hp<=0) gameOver();
            }
        }
        hit(d) {
            this.hp -= d;
            texts.push({x:this.x, y:this.y-20, t:Math.floor(d), life:1, c:'white'});
            if(this.hp <= 0) {
                this.dead = true;
                player.kills++;
                exps.push({x:this.x, y:this.y, v:10});
                spawnParticles(this.x, this.y, this.color, 5);
            }
        }
        draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath(); ctx.moveTo(this.x, this.y-this.r);
            ctx.lineTo(this.x+this.r, this.y+this.r); ctx.lineTo(this.x-this.r, this.y+this.r);
            ctx.fill();
        }
    }

    // --- ÊäÄËÉΩÂÆö‰πâÂ∫ì ---
    const SKILL_DB = [
        { id:'shot', name:'Plasma Gun', godName:'GOD SLAYER', desc:'Fire basic energy bolts.', godDesc:'Fires massive piercing beams.', color:C.bullet, icon:'üî´' },
        { id:'guardian', name:'Ion Shield', godName:'ION STORM', desc:'Orbiting defensive orbs.', godDesc:'Creates an impenetrable electric storm.', color:C.shield, icon:'üõ°Ô∏è' },
        { id:'blackhole', name:'Gravity Well', godName:'EVENT HORIZON', desc:'Summon a void that sucks enemies.', godDesc:'Summons a massive tear in reality.', color:C.blackhole, icon:'üåå' }
    ];

    function openUpgradeMenu() {
        state = 'upgrade';
        const ui = document.getElementById('upgrade-screen');
        const box = document.getElementById('cards-container');
        ui.classList.remove('hidden');
        box.innerHTML = '';
        
        // ÁîüÊàê3‰∏™ÈÄâÈ°π
        // ËøáÊª§ÊéâÂ∑≤ÁªèËßâÈÜí(Lv 5)ÁöÑÊäÄËÉΩÔºåÈô§ÈùûÊúâÊó†ÈôêÊàêÈïøÁöÑËÆæËÆ°„ÄÇËøôÈáåÂÅáËÆæLv5ÊòØÊª°Á∫ß„ÄÇ
        let pool = SKILL_DB.filter(s => !player.awakened[s.id]);
        
        // ÈöèÊú∫Âèñ3‰∏™ (Â¶ÇÊûúÊ±†Â≠êÁ©∫‰∫ÜÂ∞±ÁªôË°•Ë°Ä)
        let choices = [];
        for(let i=0; i<3; i++) {
            if(pool.length === 0) break;
            const idx = Math.floor(Math.random()*pool.length);
            choices.push(pool[idx]);
        }
        
        if(choices.length === 0) {
            // ÂÖ®Êª°Á∫ßÔºåÁªôÂõûË°Ä
            choices.push({id:'heal', name:'Medkit', desc:'Heal 50% HP', color:'#0f0', icon:'‚ù§Ô∏è'});
        }

        choices.forEach(s => {
            const card = document.createElement('div');
            card.className = 'card';
            
            // Ê£ÄÊü•ÂΩìÂâçÁ≠âÁ∫ß
            let currentLvl = player.levels[s.id] || 0;
            let isAwakening = (currentLvl === 4); // Â¶ÇÊûúÁé∞Âú®ÊòØ4Á∫ßÔºå‰∏ãÊ¨°Â∞±ÊòØ5Á∫ß(ËßâÈÜí)
            
            if(s.id === 'heal') isAwakening = false;

            card.style.setProperty('--c', isAwakening ? C.bullet_god : s.color);
            if(isAwakening) card.classList.add('is-awakening');

            let title = isAwakening ? `AWAKEN: ${s.godName}` : (s.id==='heal'?s.name:s.name);
            let desc = isAwakening ? s.godDesc : s.desc;
            let badge = s.id==='heal' ? '' : `Lvl ${currentLvl} ‚ûú ${currentLvl+1}`;
            if(isAwakening) badge = "‚ö†Ô∏è ULTIMATE EVOLUTION ‚ö†Ô∏è";

            card.innerHTML = `
                <div class="lvl-badge">${badge}</div>
                <div class="card-icon">${s.icon}</div>
                <h3 class="${isAwakening?'awakened-text':''}">${title}</h3>
                <p style="color:#aaa; font-size:12px;">${desc}</p>
            `;
            
            card.onclick = () => {
                applyUpgrade(s.id);
                ui.classList.add('hidden');
                state = 'running';
                loop();
            };
            box.appendChild(card);
        });
    }

    function applyUpgrade(id) {
        if(id === 'heal') {
            player.hp = Math.min(player.maxHp, player.hp+50);
            updateHUD();
            return;
        }
        
        player.levels[id]++;
        
        // Ê£ÄÊü•ËßâÈÜí
        if(player.levels[id] === 5) {
            player.awakened[id] = true;
            triggerAwakeningEffect();
        }
    }

    function triggerAwakeningEffect() {
        const banner = document.getElementById('awakening-banner');
        banner.classList.add('show');
        screenShake = 20; // ÂâßÁÉàÈúáÂä®
        // ÂÖ®Â±èÈó™ÂÖâ
        const flash = document.createElement('div');
        flash.style.cssText = "position:absolute;top:0;left:0;width:100%;height:100%;background:white;z-index:999;opacity:0.8;transition:0.5s;";
        document.body.appendChild(flash);
        setTimeout(() => flash.style.opacity=0, 50);
        setTimeout(() => flash.remove(), 500);
        setTimeout(() => banner.classList.remove('show'), 2000);
    }

    // --- ÂºïÊìéÊ†∏ÂøÉ ---
    let player;
    let bullets=[], enemies=[], objs=[], exps=[], texts=[], particles=[];
    let keys={};
    let screenShake = 0;

    window.onkeydown = e => keys[e.key]=true;
    window.onkeyup = e => keys[e.key]=false;

    function startGame() {
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('hud-layer').classList.remove('hidden');
        player = new Player();
        bullets=[]; enemies=[]; objs=[]; exps=[]; texts=[]; particles=[];
        state = 'running';
        updateHUD();
        loop();
    }

    function loop() {
        if(state !== 'running') return;
        requestAnimationFrame(loop);
        frame++;

        // ËÉåÊôØÊ∏ÖÁêÜ
        ctx.fillStyle = '#050505'; ctx.fillRect(0,0,canvas.width,canvas.height);
        
        // ÈúáÂä®Â§ÑÁêÜ
        ctx.save();
        if(screenShake > 0) {
            ctx.translate((Math.random()-0.5)*screenShake, (Math.random()-0.5)*screenShake);
            screenShake *= 0.9;
            if(screenShake<0.5) screenShake=0;
        }

        // ÁªòÂà∂ÁΩëÊ†º
        ctx.strokeStyle = '#111'; ctx.beginPath();
        const gs=50;
        const ox=bgOffset.x%gs; const oy=bgOffset.y%gs;
        for(let x=ox; x<canvas.width; x+=gs) { ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); }
        for(let y=oy; y<canvas.height; y+=gs) { ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); }
        ctx.stroke();

        // Âà∑ÊÄ™
        if(frame%(Math.max(10, 50-player.level))===0) enemies.push(new Enemy());

        // Êõ¥Êñ∞
        player.update(); player.draw();
        
        [bullets, enemies, objs, exps, particles].forEach(arr => {
            for(let i=arr.length-1; i>=0; i--) {
                arr[i].update(); arr[i].draw();
                if(arr[i].life!==undefined && arr[i].life<=0) arr.splice(i,1);
                else if(arr[i].dead) arr.splice(i,1);
            }
        });

        // ÁªèÈ™åÁêÉÈÄªËæë
        exps.forEach(e => {
            ctx.fillStyle = C.exp; ctx.beginPath(); ctx.arc(e.x,e.y,3,0,Math.PI*2); ctx.fill();
            if(Math.hypot(player.x-e.x, player.y-e.y) < 100) {
                e.x+=(player.x-e.x)*0.15; e.y+=(player.y-e.y)*0.15;
            }
            if(Math.hypot(player.x-e.x, player.y-e.y) < 20) {
                e.dead=true; player.gainExp(e.v);
            }
        });

        // È£òÂ≠ó
        texts = texts.filter(t => t.life>0);
        texts.forEach(t => {
            t.y-=0.5; t.life-=0.02;
            ctx.globalAlpha=t.life; ctx.fillStyle=t.c;
            ctx.font="16px Orbitron"; ctx.fillText(t.t, t.x, t.y);
            ctx.globalAlpha=1;
        });

        // HUD Êó∂Èó¥
        if(frame%60===0) {
            const s=Math.floor(frame/60);
            document.getElementById('timer').innerText = 
                `${Math.floor(s/60).toString().padStart(2,'0')}:${(s%60).toString().padStart(2,'0')}`;
        }
        
        ctx.restore();
    }

    function updateHUD() {
        document.getElementById('exp-bar').style.width = (player.exp/player.nextExp*100)+'%';
    }

    function findNearest(x,y) {
        let n=null, min=Infinity;
        enemies.forEach(e => {
            const d=Math.hypot(e.x-x, e.y-y);
            if(d<min) { min=d; n=e; }
        });
        return n;
    }

    function spawnParticles(x,y,c,n) {
        for(let i=0; i<n; i++) particles.push({
            x:x, y:y, vx:(Math.random()-0.5)*5, vy:(Math.random()-0.5)*5,
            life:1, color:c, 
            update:function(){this.x+=this.vx;this.y+=this.vy;this.life-=0.05;},
            draw:function(){ctx.globalAlpha=this.life;ctx.fillStyle=this.color;ctx.fillRect(this.x,this.y,3,3);ctx.globalAlpha=1;}
        });
    }

    function gameOver() {
        state = 'gameover';
        document.getElementById('game-over').classList.remove('hidden');
        document.getElementById('final-score').innerText = `Kills: ${player.kills} | Level: ${player.level}`;
    }

    function reroll() { openUpgradeMenu(); }
</script>
</body>
</html>
