<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Neon Survivor v3.0</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0; overflow: hidden; background-color: #050505;
            font-family: 'Orbitron', sans-serif; color: white; user-select: none;
        }
        canvas { display: block; }

        /* --- UI å±‚ --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
        }

        /* é¡¶éƒ¨ HUD */
        .hud-top {
            position: absolute; top: 20px; left: 20px; right: 20px;
            display: flex; justify-content: space-between; align-items: flex-start;
        }

        /* ç»éªŒæ¡å®¹å™¨ */
        .exp-container {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            width: 400px; height: 24px;
            background: rgba(0,0,0,0.6); border: 2px solid #333;
            border-radius: 12px; overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
        }
        .exp-fill {
            height: 100%; width: 0%;
            background: linear-gradient(90deg, #00c6ff, #0072ff);
            box-shadow: 0 0 10px #00c6ff;
            transition: width 0.2s;
        }
        .level-badge {
            position: absolute; top: -5px; left: 50%; transform: translateX(-50%);
            background: #000; border: 2px solid #00c6ff;
            width: 40px; height: 40px; border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-weight: 900; color: #00c6ff; box-shadow: 0 0 15px #00c6ff;
            z-index: 2;
        }

        /* å·¦ä¸Šè§’çŠ¶æ€ */
        .stats-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px; border-radius: 8px; border-left: 4px solid #ff0055;
            backdrop-filter: blur(4px);
        }

        /* å‡çº§èœå• - æ¯›ç»ç’ƒé£æ ¼ */
        #upgrade-menu {
            pointer-events: auto; display: none;
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            flex-direction: column; justify-content: center; align-items: center;
            z-index: 100;
        }
        #upgrade-menu h2 {
            font-size: 36px; color: #fff; text-transform: uppercase;
            text-shadow: 0 0 20px #ff0055; margin-bottom: 40px;
            letter-spacing: 4px;
        }
        .cards-container { display: flex; gap: 30px; }
        
        /* ç‚«é…·å¡ç‰‡ */
        .card {
            width: 200px; height: 280px;
            background: rgba(30, 30, 35, 0.9);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 16px;
            padding: 20px;
            cursor: pointer;
            position: relative;
            transition: 0.3s;
            display: flex; flex-direction: column; align-items: center; text-align: center;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .card:hover {
            transform: translateY(-15px);
            border-color: var(--card-color);
            box-shadow: 0 0 30px var(--card-color);
        }
        .card::before { /* æµå…‰æ•ˆæœ */
            content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.05), transparent);
            transform: rotate(45deg); animation: shine 3s infinite;
        }
        @keyframes shine { 0% {top:-150%; left:-150%;} 100% {top:150%; left:150%;} }
        
        .card-icon { font-size: 60px; margin: 20px 0; filter: drop-shadow(0 0 10px var(--card-color)); }
        .card-title { font-size: 18px; font-weight: bold; color: var(--card-color); margin-bottom: 10px; }
        .card-desc { font-size: 12px; color: #aaa; line-height: 1.5; }
        .rarity { 
            position: absolute; top: 10px; right: 10px; font-size: 10px; 
            padding: 2px 6px; border-radius: 4px; background: rgba(255,255,255,0.1); 
        }

        /* æ¸¸æˆç»“æŸ */
        #game-over {
            pointer-events: auto; display: none;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1a000a, #330000);
            padding: 40px 80px; border-radius: 20px; text-align: center;
            border: 2px solid #ff0000; box-shadow: 0 0 50px rgba(255, 0, 0, 0.5);
        }
        button {
            background: #ff0055; color: white; border: none; padding: 15px 40px;
            font-family: 'Orbitron'; font-size: 18px; font-weight: bold;
            border-radius: 30px; cursor: pointer; margin-top: 20px;
            box-shadow: 0 0 20px rgba(255, 0, 85, 0.4); transition: 0.2s;
        }
        button:hover { transform: scale(1.1); background: #ff3377; }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="stats-box">
                <div id="hp-text" style="color:#ff4444">HP: 100/100</div>
                <div id="time-text">TIME: 00:00</div>
            </div>
            
            <div class="exp-container">
                <div class="level-badge" id="level-num">1</div>
                <div class="exp-fill" id="exp-fill"></div>
            </div>
            
            <div class="stats-box" style="border-left:none; border-right: 4px solid #00c6ff; text-align:right;">
                <div id="score-text">KILLS: 0</div>
            </div>
        </div>

        <div id="upgrade-menu">
            <h2>SYSTEM UPGRADE</h2>
            <div class="cards-container" id="cards-container"></div>
        </div>

        <div id="game-over">
            <h1 style="color: #ff0055; font-size: 48px; margin: 0;">CRITICAL FAILURE</h1>
            <p id="final-stats" style="margin: 20px 0; color: #ccc;">...</p>
            <button onclick="location.reload()">REBOOT SYSTEM</button>
        </div>
    </div>

<script>
    // --- å¼•æ“åŸºç¡€ ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // èƒŒæ™¯ç½‘æ ¼åç§»é‡
    let bgOffsetX = 0, bgOffsetY = 0;

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // å±å¹•éœ‡åŠ¨
    let shakeStrength = 0;

    // --- æ¸¸æˆèµ„æº ---
    // ä¸ºäº†ç¾è§‚ï¼Œæˆ‘ä»¬è¿™æ¬¡ç”¨ç®€å•çš„ç¨‹åºåŒ–å›¾å½¢ï¼Œä½†åŠ ä¸Šäº†å¤§é‡ç‰¹æ•ˆ
    // å¦‚æœä½ æœ‰å›¾ç‰‡ï¼Œå¯ä»¥éšæ—¶æ›¿æ¢ draw() æ–¹æ³•é‡Œçš„å†…å®¹

    // --- å®ä½“ç±» ---

    class Player {
        constructor() {
            this.x = canvas.width / 2;
            this.y = canvas.height / 2;
            this.radius = 15;
            
            this.hp = 100;
            this.maxHp = 100;
            this.speed = 4;
            this.exp = 0;
            this.level = 1;
            this.nextLevelExp = 20;
            this.kills = 0;

            // æ­¦å™¨ä¸æŠ€èƒ½æ•°æ®
            this.weapon = {
                damage: 15,
                fireRate: 30, // å¸§æ•°
                cooldown: 0,
                count: 1, // å¤šé‡å°„å‡»
                pierce: 0,
                speed: 8
            };

            // è¢«åŠ¨/ç‰¹æ®ŠæŠ€èƒ½æ± 
            this.skills = {
                guardianOrbs: 0, // ç¯ç»•çƒæ•°é‡
                chainLightning: 0, // é—ªç”µç­‰çº§
                ricochet: 0, // å¼¹å°„æ¬¡æ•°
                iceField: 0 // å†°å†»å…‰ç¯
            };
            
            // ç¯ç»•çƒè§’åº¦
            this.orbAngle = 0;
            // å†°å†»è®¡æ—¶
            this.iceTimer = 0;
        }

        update() {
            // ç§»åŠ¨
            let dx = 0, dy = 0;
            if (keys['w'] || keys['ArrowUp']) dy -= 1;
            if (keys['s'] || keys['ArrowDown']) dy += 1;
            if (keys['a'] || keys['ArrowLeft']) dx -= 1;
            if (keys['d'] || keys['ArrowRight']) dx += 1;
            
            if (dx !== 0 || dy !== 0) {
                const len = Math.hypot(dx, dy);
                dx /= len; dy /= len;
                this.x += dx * this.speed;
                this.y += dy * this.speed;
                
                // èƒŒæ™¯ç§»åŠ¨æ•ˆæœ (è§†å·®)
                bgOffsetX -= dx * this.speed * 0.5;
                bgOffsetY -= dy * this.speed * 0.5;
            }

            // è¾¹ç•Œ
            this.x = Math.max(20, Math.min(canvas.width-20, this.x));
            this.y = Math.max(20, Math.min(canvas.height-20, this.y));

            // ä¸»æ­¦å™¨è‡ªåŠ¨å°„å‡»
            if (this.weapon.cooldown > 0) this.weapon.cooldown--;
            else {
                const target = findNearestEnemy(this.x, this.y);
                if (target) {
                    this.shoot(target);
                    this.weapon.cooldown = this.weapon.fireRate;
                }
            }

            // --- æŠ€èƒ½é€»è¾‘ ---
            
            // 1. ç¯ç»•æŠ¤å« (Guardian Orbs)
            if (this.skills.guardianOrbs > 0) {
                this.orbAngle += 0.05;
                const orbRadius = 70;
                for (let i = 0; i < this.skills.guardianOrbs; i++) {
                    const angle = this.orbAngle + (Math.PI * 2 / this.skills.guardianOrbs) * i;
                    const ox = this.x + Math.cos(angle) * orbRadius;
                    const oy = this.y + Math.sin(angle) * orbRadius;
                    
                    // ç»˜åˆ¶å…‰çƒ (è¿™é‡Œç›´æ¥åœ¨Updateé‡Œç”»æ˜¯ä¸ºäº†ç®€å•ï¼Œæ­£è§„åº”åœ¨Draw)
                    // ä½†ä¸ºäº†é€»è¾‘ç»Ÿä¸€ï¼Œæˆ‘ä»¬åªåšç¢°æ’æ£€æµ‹
                    enemies.forEach(e => {
                        if (Math.hypot(e.x - ox, e.y - oy) < 20) { // å…‰çƒåŠå¾„20
                            e.takeDamage(2); // å…‰çƒä¼¤å®³ä½ä½†é¢‘ç‡æé«˜
                        }
                    });
                }
            }

            // 2. å†°éœœé¢†åŸŸ
            if (this.skills.iceField > 0) {
                this.iceTimer++;
                if (this.iceTimer > 180) { // æ¯3ç§’è§¦å‘ä¸€æ¬¡
                    this.iceTimer = 0;
                    createNova(this.x, this.y, 150 + this.skills.iceField * 50, '#00ffff');
                    enemies.forEach(e => {
                        if (Math.hypot(e.x - this.x, e.y - this.y) < 150 + this.skills.iceField * 50) {
                            e.freeze(120); // å†»ç»“2ç§’
                            e.takeDamage(10);
                        }
                    });
                }
            }
        }

        draw() {
            // ç»˜åˆ¶ä¸»è§’ (å¸¦æ–¹å‘çš„ä¸‰è§’å½¢)
            ctx.save();
            ctx.translate(this.x, this.y);
            // ç®€å•æœå‘é¼ æ ‡æˆ–ç§»åŠ¨æ–¹å‘
            
            // æ ¸å¿ƒ
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI*2);
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 20; ctx.shadowColor = '#00c6ff';
            ctx.fill();
            
            // ç¯ç»•çƒç»˜åˆ¶
            if (this.skills.guardianOrbs > 0) {
                const orbRadius = 70;
                for (let i = 0; i < this.skills.guardianOrbs; i++) {
                    const angle = this.orbAngle + (Math.PI * 2 / this.skills.guardianOrbs) * i;
                    const ox = Math.cos(angle) * orbRadius;
                    const oy = Math.sin(angle) * orbRadius;
                    
                    ctx.beginPath();
                    ctx.arc(ox, oy, 8, 0, Math.PI*2);
                    ctx.fillStyle = '#ffaa00';
                    ctx.shadowColor = '#ffaa00';
                    ctx.shadowBlur = 10;
                    ctx.fill();
                }
            }

            // å†°éœœå…‰ç¯èŒƒå›´æŒ‡ç¤º
            if (this.skills.iceField > 0) {
                 ctx.beginPath();
                 ctx.arc(0, 0, 150 + this.skills.iceField * 50, 0, Math.PI*2);
                 ctx.strokeStyle = `rgba(0, 255, 255, ${this.iceTimer/180 * 0.3})`;
                 ctx.lineWidth = 2;
                 ctx.stroke();
            }

            ctx.restore();
        }

        shoot(target) {
            const angle = Math.atan2(target.y - this.y, target.x - this.x);
            // å¤šé‡å°„å‡»
            const spread = 0.2; 
            const startAngle = angle - (spread * (this.weapon.count - 1)) / 2;
            
            for(let i=0; i<this.weapon.count; i++) {
                const finalAngle = startAngle + i * spread;
                const vx = Math.cos(finalAngle) * this.weapon.speed;
                const vy = Math.sin(finalAngle) * this.weapon.speed;
                projectiles.push(new Bullet(this.x, this.y, vx, vy, this.weapon.damage, this.skills.ricochet));
            }
            // é—ªç”µè§¦å‘ (è¢«åŠ¨)
            if (this.skills.chainLightning > 0 && Math.random() < 0.3) {
                 createLightning(this.x, this.y, target.x, target.y, 3 + this.skills.chainLightning);
                 target.takeDamage(10 + this.skills.chainLightning * 5);
            }
        }

        gainExp(val) {
            this.exp += val;
            if (this.exp >= this.nextLevelExp) {
                this.exp -= this.nextLevelExp;
                this.level++;
                this.nextLevelExp = Math.floor(this.nextLevelExp * 1.3);
                levelUp();
            }
            updateHUD();
        }
    }

    // --- å­å¼¹ç±» ---
    class Bullet {
        constructor(x, y, vx, vy, dmg, bounce) {
            this.x = x; this.y = y; this.vx = vx; this.vy = vy;
            this.damage = dmg; 
            this.bounce = bounce; // å‰©ä½™å¼¹å°„æ¬¡æ•°
            this.life = 60; // å­˜åœ¨æ—¶é—´
            this.hitList = []; // é˜²æ­¢å•å¸§å¤šæ¬¡ä¼¤å®³
        }
        update() {
            this.x += this.vx; this.y += this.vy;
            this.life--;
            
            // æ‹–å°¾ç‰¹æ•ˆ
            if (frame % 2 === 0) particles.push(new Particle(this.x, this.y, '#00c6ff', 0.5, 2));

            // ç¢°æ’æ£€æµ‹
            for (let e of enemies) {
                if (!this.hitList.includes(e.id) && Math.hypot(e.x - this.x, e.y - this.y) < e.radius + 5) {
                    e.takeDamage(this.damage);
                    this.hitList.push(e.id);
                    createPopText(e.x, e.y, Math.floor(this.damage), '#fff');
                    
                    // å¼¹å°„é€»è¾‘
                    if (this.bounce > 0) {
                        this.bounce--;
                        const nextTarget = findNearestEnemy(this.x, this.y, [e.id]);
                        if (nextTarget) {
                            const angle = Math.atan2(nextTarget.y - this.y, nextTarget.x - this.x);
                            const speed = Math.hypot(this.vx, this.vy);
                            this.vx = Math.cos(angle) * speed;
                            this.vy = Math.sin(angle) * speed;
                            this.hitList = []; // é‡ç½®å‘½ä¸­åˆ—è¡¨ä»¥ä¾¿æ‰“ä¸‹ä¸€ä¸ª
                        } else {
                            this.life = 0; // æ²¡æ€ªå¼¹äº†å°±é”€æ¯
                        }
                    } else {
                        this.life = 0;
                    }
                    break; 
                }
            }
        }
        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, 4, 0, Math.PI*2);
            ctx.fillStyle = '#aaddff'; ctx.fill();
        }
    }

    // --- æ•Œäººç±» ---
    let enemyIdCounter = 0;
    class Enemy {
        constructor(type) {
            this.id = enemyIdCounter++;
            // ç”Ÿæˆåœ¨å±å¹•å¤–
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.max(canvas.width, canvas.height) * 0.7;
            this.x = player.x + Math.cos(angle) * dist;
            this.y = player.y + Math.sin(angle) * dist;
            
            // ç±»å‹å±æ€§
            if (type === 'tank') {
                this.hp = 100 + player.level * 20;
                this.speed = 1.5;
                this.radius = 20;
                this.color = '#ff0055';
                this.exp = 20;
            } else if (type === 'fast') {
                this.hp = 20 + player.level * 5;
                this.speed = 3.5;
                this.radius = 10;
                this.color = '#ffcc00';
                this.exp = 5;
            } else { // normal
                this.hp = 40 + player.level * 10;
                this.speed = 2.2;
                this.radius = 15;
                this.color = '#cc00ff';
                this.exp = 10;
            }
            
            this.maxHp = this.hp;
            this.frozenTimer = 0;
            this.pushback = {x:0, y:0};
        }

        takeDamage(amt) {
            this.hp -= amt;
            this.pushback.x += (this.x - player.x) * 0.1; // ç®€å•çš„å‡»é€€
            this.pushback.y += (this.y - player.y) * 0.1;
            
            if (this.hp <= 0) {
                player.kills++;
                player.gainExp(this.exp);
                createExplosion(this.x, this.y, this.color);
                shakeStrength = 3; // å±å¹•éœ‡åŠ¨
                this.dead = true;
            }
        }

        freeze(time) {
            this.frozenTimer = time;
        }

        update() {
            // å†°å†»é€»è¾‘
            let currentSpeed = this.speed;
            if (this.frozenTimer > 0) {
                this.frozenTimer--;
                currentSpeed *= 0.2; // å‡é€Ÿ80%
                if (frame % 5 === 0) particles.push(new Particle(this.x, this.y, '#00ffff', 0.2, 1)); // æ‰å†°æ¸£
            }

            const angle = Math.atan2(player.y - this.y, player.x - this.x);
            
            // ç§»åŠ¨
            this.x += Math.cos(angle) * currentSpeed + this.pushback.x;
            this.y += Math.sin(angle) * currentSpeed + this.pushback.y;
            
            // å‡»é€€è¡°å‡
            this.pushback.x *= 0.8;
            this.pushback.y *= 0.8;

            // æ’ç©å®¶
            const dist = Math.hypot(player.x - this.x, player.y - this.y);
            if (dist < this.radius + player.radius) {
                player.hp -= 0.5; // æŒç»­ä¼¤å®³
                shakeStrength = 5;
                updateHUD();
                if (player.hp <= 0) gameOver();
            }
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            
            ctx.beginPath();
            if (this.radius > 18) { // Tank: æ­£æ–¹å½¢
                 ctx.rect(-this.radius, -this.radius, this.radius*2, this.radius*2);
            } else { // Circle
                 ctx.arc(0, 0, this.radius, 0, Math.PI*2);
            }
            
            ctx.fillStyle = this.frozenTimer > 0 ? '#00ffff' : this.color;
            ctx.shadowBlur = 10; ctx.shadowColor = this.color;
            ctx.fill();
            
            // è¡€æ¡
            ctx.fillStyle = 'red';
            ctx.fillRect(-15, -this.radius-10, 30, 4);
            ctx.fillStyle = '#0f0';
            ctx.fillRect(-15, -this.radius-10, 30 * (Math.max(0, this.hp)/this.maxHp), 4);
            
            ctx.restore();
        }
    }

    // --- ç‰¹æ•ˆç±» ---
    class Particle {
        constructor(x, y, color, speed, size) {
            this.x = x; this.y = y; this.color = color;
            const a = Math.random() * Math.PI*2;
            const s = Math.random() * speed;
            this.vx = Math.cos(a) * s; this.vy = Math.sin(a) * s;
            this.life = 1.0; this.decay = 0.02 + Math.random()*0.03;
            this.size = size;
        }
        update() { this.x+=this.vx; this.y+=this.vy; this.life-=this.decay; }
        draw() { 
            ctx.globalAlpha = Math.max(0, this.life); 
            ctx.fillStyle = this.color; 
            ctx.fillRect(this.x, this.y, this.size, this.size); 
            ctx.globalAlpha = 1;
        }
    }
    
    class PopText {
        constructor(x, y, text, color) {
            this.x = x; this.y = y; this.text = text; this.color = color;
            this.life = 1.0; this.vy = -1;
        }
        update() { this.y += this.vy; this.life -= 0.02; }
        draw() {
            ctx.globalAlpha = Math.max(0, this.life);
            ctx.fillStyle = this.color;
            ctx.font = "bold 20px 'Orbitron'";
            ctx.fillText(this.text, this.x, this.y);
            ctx.globalAlpha = 1;
        }
    }

    // --- å…¨å±€å˜é‡ä¸å·¥å…· ---
    let player = new Player();
    let projectiles = [];
    let enemies = [];
    let particles = [];
    let texts = [];
    let frame = 0;
    let state = 'running';
    let keys = {};

    window.addEventListener('keydown', e => keys[e.key] = true);
    window.addEventListener('keyup', e => keys[e.key] = false);

    function findNearestEnemy(x, y, excludeIds=[]) {
        let nearest = null; let minD = Infinity;
        for(let e of enemies) {
            if(excludeIds.includes(e.id)) continue;
            let d = Math.hypot(e.x-x, e.y-y);
            if(d < minD) { minD = d; nearest = e; }
        }
        return nearest;
    }

    function createExplosion(x, y, color) {
        for(let i=0; i<10; i++) particles.push(new Particle(x, y, color, 3, 3));
    }
    
    function createPopText(x, y, txt, col) {
        texts.push(new PopText(x, y, txt, col));
    }

    function createNova(x, y, r, color) {
        // è§†è§‰ç‰¹æ•ˆï¼šä¸€ä¸ªæ‰©å¤§çš„åœ†ç¯
        // è¿™é‡Œç®€å•ç”¨ç²’å­æ¨¡æ‹Ÿ
        for(let i=0; i<20; i++) {
             let p = new Particle(x, y, color, 8, 4);
             p.decay = 0.05;
             particles.push(p);
        }
    }
    
    function createLightning(x1, y1, x2, y2, segments) {
        // ç®€åŒ–ç‰ˆé—ªç”µï¼šç›´æ¥ç”»çº¿
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.shadowBlur = 15; ctx.shadowColor = '#00ffff';
        ctx.stroke();
        ctx.restore();
    }

    // --- å‡çº§ç³»ç»Ÿ ---
    const upgradePool = [
        { id: 'guardian', name: 'ç¦»å­æŠ¤ç›¾', desc: 'å¬å”¤/å¢åŠ ç¯ç»•çƒä½“', color: '#ffaa00', icon: 'ğŸ›¡ï¸',
          apply: () => player.skills.guardianOrbs++ },
        { id: 'multishot', name: 'æ•£å°„åŠ å†œ', desc: 'å­å¼¹æ•°é‡ +1', color: '#00ff00', icon: 'ğŸ”«',
          apply: () => player.weapon.count++ },
        { id: 'damage', name: 'é«˜èƒ½æ ¸å¿ƒ', desc: 'ä¼¤å®³ +20%', color: '#ff0055', icon: 'ğŸ’¥',
          apply: () => player.weapon.damage *= 1.2 },
        { id: 'ricochet', name: 'è·³å¼¹æ¨¡ç»„', desc: 'å­å¼¹å¼¹å°„æ¬¡æ•° +1', color: '#00c6ff', icon: 'ğŸ±',
          apply: () => player.skills.ricochet++ },
        { id: 'chain', name: 'ç”µå¼§å‘ç”Ÿå™¨', desc: 'æ”»å‡»è§¦å‘é—ªç”µé“¾', color: '#aa00ff', icon: 'âš¡',
          apply: () => player.skills.chainLightning++ },
        { id: 'ice', name: 'æ¶²æ°®å…‰ç¯', desc: 'å‘¨æœŸæ€§å†»ç»“å‘¨å›´', color: '#00ffff', icon: 'â„ï¸',
          apply: () => player.skills.iceField++ },
        { id: 'haste', name: 'è¶…é¢‘è£…ç½®', desc: 'æ”»é€Ÿ +15%', color: '#ffff00', icon: 'â©',
          apply: () => player.weapon.fireRate = Math.max(5, player.weapon.fireRate * 0.85) }
    ];

    function levelUp() {
        state = 'paused';
        const menu = document.getElementById('upgrade-menu');
        const container = document.getElementById('cards-container');
        container.innerHTML = '';
        
        // éšæœºæŠ½3ä¸ª
        const choices = [...upgradePool].sort(() => 0.5 - Math.random()).slice(0, 3);
        
        choices.forEach(u => {
            const card = document.createElement('div');
            card.className = 'card';
            card.style.setProperty('--card-color', u.color);
            card.innerHTML = `
                <div class="rarity">RARE</div>
                <div class="card-icon">${u.icon}</div>
                <div class="card-title">${u.name}</div>
                <div class="card-desc">${u.desc}</div>
            `;
            card.onclick = () => {
                u.apply();
                menu.style.display = 'none';
                state = 'running';
                animate();
            };
            container.appendChild(card);
        });
        
        menu.style.display = 'flex';
    }

    function updateHUD() {
        document.getElementById('hp-text').innerText = `HP: ${Math.floor(player.hp)}/${player.maxHp}`;
        document.getElementById('score-text').innerText = `KILLS: ${player.kills}`;
        document.getElementById('level-num').innerText = player.level;
        const pct = (player.exp / player.nextLevelExp) * 100;
        document.getElementById('exp-fill').style.width = pct + '%';
    }

    function gameOver() {
        state = 'gameover';
        document.getElementById('game-over').style.display = 'block';
        document.getElementById('final-stats').innerText = `Survived Levels: ${player.level} | Kills: ${player.kills}`;
    }

    // --- ä¸»å¾ªç¯ ---
    function animate() {
        if (state !== 'running') return;
        requestAnimationFrame(animate);
        frame++;

        // ç»˜åˆ¶èƒŒæ™¯ (ç½‘æ ¼)
        ctx.fillStyle = '#050505';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // ç®€å•çš„åŠ¨æ€ç½‘æ ¼
        ctx.strokeStyle = '#1a1a1a';
        ctx.lineWidth = 1;
        ctx.beginPath();
        const gridSize = 50;
        const offX = bgOffsetX % gridSize;
        const offY = bgOffsetY % gridSize;
        for(let x=offX; x<canvas.width; x+=gridSize) { ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); }
        for(let y=offY; y<canvas.height; y+=gridSize) { ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); }
        ctx.stroke();

        // å±å¹•éœ‡åŠ¨åº”ç”¨
        ctx.save();
        if (shakeStrength > 0) {
            const dx = (Math.random()-0.5) * shakeStrength;
            const dy = (Math.random()-0.5) * shakeStrength;
            ctx.translate(dx, dy);
            shakeStrength *= 0.9;
            if(shakeStrength < 0.5) shakeStrength = 0;
        }

        // ç”Ÿæˆæ€ªç‰©
        if (frame % Math.max(20, 60 - player.level) === 0) {
            const r = Math.random();
            if (r < 0.1 && player.level > 3) enemies.push(new Enemy('tank'));
            else if (r < 0.3 && player.level > 2) enemies.push(new Enemy('fast'));
            else enemies.push(new Enemy('normal'));
        }

        // æ›´æ–°é€»è¾‘
        player.update();
        player.draw();

        projectiles = projectiles.filter(p => p.life > 0);
        projectiles.forEach(p => { p.update(); p.draw(); });

        enemies = enemies.filter(e => !e.dead);
        enemies.forEach(e => { e.update(); e.draw(); });

        particles = particles.filter(p => p.life > 0);
        particles.forEach(p => { p.update(); p.draw(); });
        
        texts = texts.filter(t => t.life > 0);
        texts.forEach(t => { t.update(); t.draw(); });

        // æ—¶é—´æ›´æ–°
        if (frame % 60 === 0) {
            const sec = Math.floor(frame / 60);
            const m = Math.floor(sec / 60).toString().padStart(2, '0');
            const s = (sec % 60).toString().padStart(2, '0');
            document.getElementById('time-text').innerText = `TIME: ${m}:${s}`;
        }

        ctx.restore(); // ç»“æŸéœ‡åŠ¨
    }

    updateHUD();
    animate();

</script>
</body>
</html>
