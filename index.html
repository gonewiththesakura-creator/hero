<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Neon Survivor v6.0 - Ultimate</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #00f3ff;
            --secondary: #ff00ff;
            --accent: #ffcc00;
            --danger: #ff3333;
            --bg: #0a0a0c;
        }
        body {
            margin: 0; overflow: hidden; background-color: var(--bg);
            font-family: 'Rajdhani', sans-serif; color: white; user-select: none;
        }
        canvas { display: block; }

        /* --- UI ÈÅÆÁΩ©Â±Ç (ÈÄöÁî®) --- */
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(10, 10, 12, 0.85);
            backdrop-filter: blur(8px); /* ÊØõÁéªÁíÉÊ†∏ÂøÉ */
            z-index: 100; opacity: 1; transition: opacity 0.3s;
            pointer-events: auto;
        }
        .hidden { opacity: 0; pointer-events: none; z-index: -1; }

        /* Ê†áÈ¢òÊ†∑Âºè */
        h1 {
            font-family: 'Orbitron', sans-serif; font-size: 72px; margin: 0;
            background: linear-gradient(to right, var(--primary), var(--secondary));
            -webkit-background-clip: text; color: transparent;
            text-shadow: 0 0 30px rgba(0, 243, 255, 0.3); letter-spacing: 4px;
        }
        h2 { font-family: 'Orbitron'; color: white; text-shadow: 0 0 10px white; margin-bottom: 30px; font-size: 36px; }

        /* ÊåâÈíÆÊ†∑Âºè */
        button {
            background: linear-gradient(135deg, rgba(0, 243, 255, 0.2), rgba(0,0,0,0));
            border: 2px solid var(--primary); color: white;
            padding: 15px 60px; font-family: 'Orbitron'; font-size: 20px; font-weight: bold;
            margin-top: 40px; cursor: pointer; border-radius: 4px;
            box-shadow: 0 0 15px var(--primary); transition: 0.2s;
            text-transform: uppercase;
        }
        button:hover {
            background: var(--primary); color: black;
            box-shadow: 0 0 40px var(--primary); transform: scale(1.05);
        }

        /* --- Ê∏∏ÊàèÂÜÖ HUD --- */
        #hud { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* ÁªèÈ™åÊù° */
        .exp-container {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            width: 400px; height: 24px; background: rgba(0,0,0,0.8);
            border: 1px solid #444; border-radius: 12px; overflow: hidden;
            box-shadow: 0 0 10px black;
        }
        .exp-fill {
            height: 100%; width: 0%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            box-shadow: 0 0 10px var(--primary); transition: width 0.2s;
        }
        .level-badge {
            position: absolute; top: 50px; left: 50%; transform: translateX(-50%);
            font-family: 'Orbitron'; font-weight: 900; font-size: 24px;
            color: var(--accent); text-shadow: 0 0 10px var(--accent);
        }
        
        /* Áä∂ÊÄÅÊ†è */
        .stats-panel {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0,0,0,0.5); padding: 15px; border-radius: 8px;
            border-left: 4px solid var(--danger); font-family: 'Orbitron';
        }
        .timer-panel {
            position: absolute; top: 20px; right: 20px;
            font-size: 32px; font-family: 'Orbitron'; text-shadow: 0 0 10px white;
        }

        /* --- ÂçáÁ∫ßÂç°ÁâáÂÆπÂô® --- */
        .cards-container { display: flex; gap: 25px; flex-wrap: wrap; justify-content: center; }
        .card {
            width: 200px; height: 300px;
            background: linear-gradient(160deg, #1a1a20, #0d0d10);
            border: 1px solid #555; border-top: 4px solid var(--color);
            border-radius: 12px; padding: 20px; cursor: pointer;
            display: flex; flex-direction: column; align-items: center; text-align: center;
            transition: 0.3s; position: relative; overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .card:hover {
            transform: translateY(-15px) scale(1.03);
            border-color: var(--color); box-shadow: 0 0 30px var(--color);
        }
        .card-icon { font-size: 50px; margin: 20px 0; filter: drop-shadow(0 0 10px var(--color)); }
        .card h3 { color: var(--color); margin: 0 0 10px 0; font-family: 'Orbitron'; font-size: 18px; }
        .card p { color: #aaa; font-size: 13px; line-height: 1.4; }
        
        /* ËßâÈÜíÂç°ÁâáÁâπÊïà */
        .card.awakened {
            background: linear-gradient(160deg, #300, #100);
            border-color: var(--accent);
            animation: pulse-gold 1.5s infinite alternate;
        }
        .card.awakened h3 { color: var(--accent); text-shadow: 0 0 10px red; }
        @keyframes pulse-gold { from { box-shadow: 0 0 10px var(--accent); } to { box-shadow: 0 0 40px var(--accent); } }

        /* ËßâÈÜíÊ®™ÂπÖ */
        #awakening-msg {
            position: absolute; top: 35%; width: 100%; text-align: center;
            font-family: 'Orbitron'; font-size: 80px; font-weight: 900;
            background: linear-gradient(to bottom, #fff, #ffcc00);
            -webkit-background-clip: text; color: transparent;
            text-shadow: 0 0 50px red; pointer-events: none;
            transform: scale(0); transition: 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 200;
        }
        #awakening-msg.show { transform: scale(1); }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    <div id="awakening-msg">ULTIMATE AWAKENED!</div>

    <div id="start-screen" class="overlay">
        <h1>NEON SURVIVOR</h1>
        <div style="color:#888; letter-spacing: 2px; margin-bottom: 40px; font-family:'Orbitron'">SYSTEM v6.0 ONLINE</div>
        <button onclick="startGame()">START MISSION</button>
        <p style="color:#555; margin-top: 20px;">[WASD] Move &nbsp;|&nbsp; Survive & Evolve</p>
    </div>

    <div id="hud" class="hidden">
        <div class="exp-container"><div class="exp-fill" id="exp-bar"></div></div>
        <div class="level-badge">LV <span id="lvl-text">1</span></div>
        <div class="stats-panel">
            <div style="color:var(--danger); font-size:20px;">HP: <span id="hp-text">100</span>%</div>
            <div style="color:#aaa; font-size:14px; margin-top:5px;">KILLS: <span id="kill-text">0</span></div>
        </div>
        <div class="timer-panel" id="timer-text">00:00</div>
    </div>

    <div id="upgrade-menu" class="overlay hidden">
        <h2>CHOOSE UPGRADE</h2>
        <div class="cards-container" id="cards-box"></div>
    </div>

    <div id="game-over" class="overlay hidden">
        <h1 style="color:var(--danger);">MISSION FAILED</h1>
        <p id="end-stats" style="color:#ccc; font-size:24px; margin:20px 0;">...</p>
        <button onclick="location.reload()">RETRY</button>
    </div>

<script>
    // --- Ê∏∏ÊàèÂºïÊìéÈÖçÁΩÆ ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // ËßÜËßâÂ∏∏Èáè
    const Colors = {
        player: '#fff',
        bullet: '#00f3ff',
        bullet_god: '#ffd700', // ËßâÈÜíÈáëËâ≤
        enemy: '#ff0055',
        exp: '#00ff66',
        orb: '#00ccff',
        orb_god: '#ffaa00',    // ËßâÈÜíÊ©ôËâ≤
        bg_grid: '#1a1a1a'
    };

    let gameState = 'start'; // start, running, paused, upgrade, gameover
    let frame = 0;
    let bgOffset = {x: 0, y: 0};
    
    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize); resize();

    // --- Ê∏∏ÊàèÁä∂ÊÄÅÊï∞ÊçÆ ---
    let player = {};
    let enemies = [];
    let bullets = [];
    let particles = [];
    let exps = [];
    let texts = []; // È£òÂ≠ó
    let keys = {};

    // --- ÊäÄËÉΩÂÆö‰πâ (Database) ---
    // maxLvl: 5 (Lv5 = ËßâÈÜí)
    const SKILLS = [
        { 
            id: 'shot', name: 'Plasma Gun', icon: 'üî´', color: '#00f3ff',
            desc: 'Fires energy bolts at enemies.',
            godName: 'GOD SLAYER', godDesc: 'Golden beams obliterate everything.',
            type: 'active'
        },
        { 
            id: 'guardian', name: 'Ion Shield', icon: 'üõ°Ô∏è', color: '#00ccff',
            desc: 'Rotating orbs damage enemies.',
            godName: 'ION STORM', godDesc: 'A storm of destruction surrounds you.',
            type: 'active'
        },
        { 
            id: 'speed', name: 'Thrusters', icon: '‚ö°', color: '#ffff00',
            desc: 'Movement Speed +10%',
            type: 'passive'
        },
        { 
            id: 'vitality', name: 'Nano Armor', icon: '‚ù§Ô∏è', color: '#ff3333',
            desc: 'Max HP +20 & Heal',
            type: 'passive'
        },
        { 
            id: 'haste', name: 'Overclock', icon: '‚è©', color: '#ffaa00',
            desc: 'Fire Rate +15%',
            type: 'passive'
        }
    ];

    // --- Ê†∏ÂøÉÁ±ª ---

    class Player {
        constructor() {
            this.x = canvas.width / 2;
            this.y = canvas.height / 2;
            this.hp = 100; this.maxHp = 100;
            this.speed = 4;
            this.level = 1; this.exp = 0; this.nextExp = 15;
            this.kills = 0;
            
            // ÊäÄËÉΩÁ≠âÁ∫ßÊï∞ÊçÆ
            this.skillLevels = {
                shot: 1,      // ÈªòËÆ§Êã•Êúâ
                guardian: 0,
                speed: 0,
                vitality: 0,
                haste: 0
            };
            
            // ÂÜ∑Âç¥ËÆ°Êó∂Âô®
            this.cooldowns = { shot: 0 };
            this.guardianAngle = 0;
        }

        update() {
            // 1. ÁßªÂä®
            let dx = 0, dy = 0;
            if (keys['w'] || keys['ArrowUp']) dy -= 1;
            if (keys['s'] || keys['ArrowDown']) dy += 1;
            if (keys['a'] || keys['ArrowLeft']) dx -= 1;
            if (keys['d'] || keys['ArrowRight']) dx += 1;

            let currentSpeed = this.speed + (this.skillLevels.speed * 0.5);
            
            if (dx || dy) {
                const len = Math.hypot(dx, dy);
                this.x += (dx/len) * currentSpeed;
                this.y += (dy/len) * currentSpeed;
                // ËÉåÊôØËßÜÂ∑ÆÁßªÂä®
                bgOffset.x -= (dx/len) * currentSpeed * 0.5;
                bgOffset.y -= (dy/len) * currentSpeed * 0.5;
            }
            
            // ËæπÁïå
            this.x = Math.max(20, Math.min(canvas.width-20, this.x));
            this.y = Math.max(20, Math.min(canvas.height-20, this.y));

            // 2. Â∞ÑÂáªÈÄªËæë
            if (this.cooldowns.shot > 0) this.cooldowns.shot--;
            else {
                const target = findNearestEnemy(this.x, this.y);
                if (target) {
                    const lvl = this.skillLevels.shot;
                    const isGod = lvl >= 5; // ËßâÈÜíÂà§ÂÆö
                    
                    // Â∞ÑÂáªÂèÇÊï∞
                    const dmg = 15 + lvl * 5 + (isGod ? 50 : 0);
                    const count = 1 + Math.floor(lvl / 2) + (isGod ? 2 : 0); // 1, 1, 2, 2, 5
                    const spread = 0.2 + (isGod ? 0.2 : 0);
                    
                    const baseAngle = Math.atan2(target.y - this.y, target.x - this.x);
                    const startAngle = baseAngle - (spread * (count-1))/2;
                    
                    for(let i=0; i<count; i++) {
                        const a = startAngle + i*spread;
                        bullets.push(new Bullet(this.x, this.y, Math.cos(a)*10, Math.sin(a)*10, dmg, isGod));
                    }
                    
                    // ÊîªÈÄüËÆ°ÁÆó (Haste Ë¢´Âä®)
                    let fireDelay = Math.max(5, 30 - this.skillLevels.haste * 3 - (isGod ? 10 : 0));
                    this.cooldowns.shot = fireDelay;
                    
                    if (isGod) spawnParticles(this.x, this.y, Colors.bullet_god, 5);
                }
            }

            // 3. Êä§ÁõæÈÄªËæë
            if (this.skillLevels.guardian > 0) {
                const lvl = this.skillLevels.guardian;
                const isGod = lvl >= 5;
                
                const count = lvl + (isGod ? 4 : 0);
                const rotSpeed = 0.05 + (isGod ? 0.1 : 0);
                const dist = 80 + (isGod ? 40 : 0);
                
                this.guardianAngle += rotSpeed;
                
                for(let i=0; i<count; i++) {
                    const a = this.guardianAngle + (Math.PI*2/count) * i;
                    const ox = this.x + Math.cos(a) * dist;
                    const oy = this.y + Math.sin(a) * dist;
                    
                    // Êä§Áõæ‰º§ÂÆ≥
                    enemies.forEach(e => {
                        if (Math.hypot(e.x - ox, e.y - oy) < (isGod?25:15)) {
                            e.hit(isGod ? 5 : 2); // È´òÈ¢ë‰Ωé‰º§
                            if(frame % 4 === 0) spawnParticles(e.x, e.y, isGod?Colors.orb_god:Colors.orb, 1);
                        }
                    });
                }
            }
        }

        draw() {
            // ÁªòÂà∂Êú¨‰Ωì
            ctx.shadowBlur = 15; ctx.shadowColor = Colors.player;
            ctx.fillStyle = Colors.player;
            ctx.beginPath(); ctx.arc(this.x, this.y, 12, 0, Math.PI*2); ctx.fill();
            
            // ÁªòÂà∂Êä§Áõæ
            if (this.skillLevels.guardian > 0) {
                const lvl = this.skillLevels.guardian;
                const isGod = lvl >= 5;
                const count = lvl + (isGod ? 4 : 0);
                const dist = 80 + (isGod ? 40 : 0);
                const color = isGod ? Colors.orb_god : Colors.orb;
                
                ctx.shadowColor = color; ctx.fillStyle = color;
                for(let i=0; i<count; i++) {
                    const a = this.guardianAngle + (Math.PI*2/count) * i;
                    const ox = this.x + Math.cos(a) * dist;
                    const oy = this.y + Math.sin(a) * dist;
                    
                    ctx.beginPath(); 
                    ctx.arc(ox, oy, isGod?8:5, 0, Math.PI*2); 
                    ctx.fill();
                    
                    // ËßâÈÜíËøûÁ∫øÁâπÊïà
                    if(isGod) {
                        ctx.strokeStyle = color; ctx.lineWidth = 1;
                        ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(ox, oy); ctx.stroke();
                    }
                }
            }
            ctx.shadowBlur = 0;
        }

        gainExp(val) {
            this.exp += val;
            if (this.exp >= this.nextExp) {
                this.exp -= this.nextExp;
                this.level++;
                this.nextExp = Math.floor(this.nextExp * 1.3);
                showUpgrade();
            }
            updateUI();
        }
    }

    class Bullet {
        constructor(x, y, vx, vy, dmg, isGod) {
            this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.dmg=dmg; this.isGod=isGod;
            this.life = 60;
        }
        update() {
            this.x += this.vx; this.y += this.vy; this.life--;
            // ËßâÈÜíÊãñÂ∞æ
            if (this.isGod && frame % 2 === 0) spawnParticles(this.x, this.y, Colors.bullet_god, 1);
            
            enemies.forEach(e => {
                if (Math.hypot(e.x - this.x, e.y - this.y) < e.r + 5) {
                    e.hit(this.dmg);
                    if (!this.isGod) this.life = 0; // ÊôÆÈÄöÂ≠êÂºπÊ∂àÂ§±ÔºåËßâÈÜíÂ≠êÂºπÁ©øÈÄè
                    else {
                        spawnParticles(e.x, e.y, Colors.bullet_god, 2); // Âáª‰∏≠ÁÅ´Ëä±
                    }
                }
            });
        }
        draw() {
            const c = this.isGod ? Colors.bullet_god : Colors.bullet;
            ctx.fillStyle = c; ctx.shadowColor = c; ctx.shadowBlur = 10;
            ctx.beginPath(); ctx.arc(this.x, this.y, this.isGod?6:4, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;
        }
    }

    class Enemy {
        constructor() {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.max(canvas.width, canvas.height) * 0.7;
            this.x = player.x + Math.cos(angle) * dist;
            this.y = player.y + Math.sin(angle) * dist;
            this.hp = 20 + player.level * 8;
            this.speed = 1.5 + Math.random() * 0.5;
            this.r = 15;
        }
        update() {
            const angle = Math.atan2(player.y - this.y, player.x - this.x);
            this.x += Math.cos(angle) * this.speed;
            this.y += Math.sin(angle) * this.speed;
            
            if (Math.hypot(player.x - this.x, player.y - this.y) < this.r + 10) {
                player.hp -= 0.5;
                updateUI();
                if (player.hp <= 0) gameOver();
            }
        }
        hit(dmg) {
            this.hp -= dmg;
            showText(this.x, this.y, Math.floor(dmg));
            if (this.hp <= 0) {
                this.dead = true;
                player.kills++;
                exps.push({x: this.x, y: this.y, val: 10});
                spawnParticles(this.x, this.y, Colors.enemy, 6);
                updateUI();
            }
        }
        draw() {
            ctx.fillStyle = Colors.enemy;
            ctx.beginPath();
            ctx.moveTo(this.x, this.y - this.r);
            ctx.lineTo(this.x + this.r, this.y + this.r);
            ctx.lineTo(this.x - this.r, this.y + this.r);
            ctx.fill();
        }
    }

    // --- Ê†∏ÂøÉÈÄªËæë ---

    function init() {
        player = new Player();
        enemies = []; bullets = []; exps = []; particles = []; texts = [];
        keys = {}; frame = 0;
        
        window.addEventListener('keydown', e => keys[e.key] = true);
        window.addEventListener('keyup', e => keys[e.key] = false);
    }

    function startGame() {
        init();
        gameState = 'running';
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('hud').classList.remove('hidden');
        updateUI();
        animate();
    }

    function showUpgrade() {
        gameState = 'upgrade';
        const menu = document.getElementById('upgrade-menu');
        const container = document.getElementById('cards-box');
        menu.classList.remove('hidden');
        container.innerHTML = '';

        // ÈöèÊú∫ÊäΩÂèñ3‰∏™ÊäÄËÉΩ
        // ËøáÊª§ËßÑÂàôÔºöÂè™ÊúâÁ≠âÁ∫ß < 5 ÁöÑÊäÄËÉΩÊâçËÉΩÂá∫Áé∞ (ËßâÈÜíÂêé‰∏çËÉΩÂÜçÂçá)
        const pool = SKILLS.filter(s => {
            const lvl = player.skillLevels[s.id] || 0;
            if (s.type === 'active') return lvl < 5; // ‰∏ªÂä®ÊäÄËÉΩ‰∏äÈôê5
            return true; // Ë¢´Âä®ÊäÄËÉΩÊöÇÊó†‰∏äÈôê
        });
        
        let choices = [];
        for(let i=0; i<3; i++) {
            if(pool.length === 0) break;
            const idx = Math.floor(Math.random() * pool.length);
            choices.push(pool[idx]);
            // ÁÆÄÂçïÁöÑÈò≤ÈáçÂ§çÈÄªËæëÔºöÂ¶ÇÊûúÊòØÈöèÊú∫ÊäΩÔºåÂÆûÈôÖÂ∫îËØ•‰ªétempPoolÈáåÁßªÈô§ÔºåËøôÈáåÁÆÄÂåñ
        }
        // Â¶ÇÊûúÊ±†Â≠êÂ§™Â∞èÔºåË°•Ë°ÄÂåÖ
        if(choices.length < 3) choices.push({id:'heal', name:'Medkit', icon:'‚ù§Ô∏è', color:'#0f0', desc:'Heal 30% HP'});

        choices.forEach(s => {
            const card = document.createElement('div');
            card.className = 'card';
            
            let lvl = player.skillLevels[s.id] || 0;
            let isAwakening = (s.type === 'active' && lvl === 4);
            
            card.style.setProperty('--color', isAwakening ? '#ffd700' : s.color);
            if (isAwakening) card.classList.add('awakened');

            let title = isAwakening ? s.godName : s.name;
            let desc = isAwakening ? s.godDesc : s.desc;
            let badge = (s.id === 'heal') ? '' : `Lv.${lvl} ‚ûú Lv.${lvl+1}`;
            if (isAwakening) badge = '‚ö†Ô∏è AWAKENING ‚ö†Ô∏è';

            card.innerHTML = `
                <div style="font-size:12px; margin-bottom:10px; color:#888;">${badge}</div>
                <div class="card-icon">${s.icon}</div>
                <h3>${title}</h3>
                <p>${desc}</p>
            `;
            
            card.onclick = () => {
                applySkill(s.id);
                menu.classList.add('hidden');
                gameState = 'running';
                animate();
            };
            container.appendChild(card);
        });
    }

    function applySkill(id) {
        if (id === 'heal') {
            player.hp = Math.min(player.maxHp, player.hp + 30);
            updateUI();
            return;
        }
        
        player.skillLevels[id]++;
        
        // Ê£ÄÊü•ËßâÈÜíËß¶Âèë
        if (player.skillLevels[id] === 5) {
            triggerAwakening();
        }
    }

    function triggerAwakening() {
        const msg = document.getElementById('awakening-msg');
        msg.classList.add('show');
        setTimeout(() => msg.classList.remove('show'), 2000);
        
        // ÂÖ®Â±èÈúáÂä®+Èó™ÂÖâ
        let flash = document.createElement('div');
        flash.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:white;opacity:0.8;transition:0.5s;z-index:999;';
        document.body.appendChild(flash);
        setTimeout(() => flash.style.opacity = 0, 50);
        setTimeout(() => flash.remove(), 500);
    }

    function animate() {
        if (gameState !== 'running') return;
        requestAnimationFrame(animate);
        frame++;

        // Ê∏ÖÁ©∫ËÉåÊôØ
        ctx.fillStyle = '#0a0a0c'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // ÁªòÂà∂ÁΩëÊ†º
        ctx.strokeStyle = '#222'; ctx.lineWidth = 1; ctx.beginPath();
        const gs = 50;
        const ox = bgOffset.x % gs; const oy = bgOffset.y % gs;
        for (let x=ox; x<canvas.width; x+=gs) { ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); }
        for (let y=oy; y<canvas.height; y+=gs) { ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); }
        ctx.stroke();

        // ÁîüÊàêÊïå‰∫∫
        if (frame % Math.max(10, 50 - player.level) === 0) enemies.push(new Enemy());

        // Êõ¥Êñ∞ÂÆû‰Ωì
        player.update(); player.draw();

        [bullets, enemies, exps, particles].forEach(arr => {
            for(let i=arr.length-1; i>=0; i--) {
                const ent = arr[i];
                if(ent.update) ent.update();
                else if(ent.draw) ent.draw(); // simple particles
                
                // ÁªòÂà∂
                if(ent.draw && ent.update) ent.draw();

                if (ent.dead || (ent.life && ent.life <= 0)) arr.splice(i, 1);
            }
        });
        
        // ÁªèÈ™åÁêÉÂê∏ÈôÑÈÄªËæë
        exps.forEach(e => {
            ctx.fillStyle = Colors.exp; ctx.beginPath(); ctx.arc(e.x, e.y, 4, 0, Math.PI*2); ctx.fill();
            const d = Math.hypot(player.x - e.x, player.y - e.y);
            if (d < 150) {
                e.x += (player.x - e.x) * 0.1; e.y += (player.y - e.y) * 0.1;
            }
            if (d < 20) {
                e.dead = true; player.gainExp(e.val);
            }
        });

        // È£òÂ≠ó
        texts = texts.filter(t => t.life > 0);
        texts.forEach(t => {
            t.y -= 1; t.life -= 0.02;
            ctx.globalAlpha = t.life; ctx.fillStyle = 'white'; ctx.font = "bold 16px sans-serif";
            ctx.fillText(t.val, t.x, t.y);
            ctx.globalAlpha = 1;
        });

        // Êó∂Èó¥Êõ¥Êñ∞
        if (frame % 60 === 0) {
            let s = Math.floor(frame/60);
            let m = Math.floor(s/60);
            document.getElementById('timer-text').innerText = `${m}:${(s%60).toString().padStart(2,'0')}`;
        }
    }

    // --- ËæÖÂä©ÂáΩÊï∞ ---
    function findNearestEnemy(x, y) {
        let n = null; let min = Infinity;
        enemies.forEach(e => {
            let d = Math.hypot(e.x - x, e.y - y);
            if (d < min) { min = d; n = e; }
        });
        return n;
    }

    function spawnParticles(x, y, c, n) {
        for(let i=0; i<n; i++) particles.push({
            x, y, vx: (Math.random()-0.5)*5, vy: (Math.random()-0.5)*5, color: c, life: 1,
            update: function() { this.x+=this.vx; this.y+=this.vy; this.life-=0.05; },
            draw: function() { ctx.globalAlpha=this.life; ctx.fillStyle=this.color; ctx.fillRect(this.x,this.y,3,3); ctx.globalAlpha=1; }
        });
    }

    function showText(x, y, val) { texts.push({x, y, val, life: 1}); }

    function updateUI() {
        document.getElementById('exp-bar').style.width = (player.exp / player.nextExp * 100) + '%';
        document.getElementById('lvl-text').innerText = player.level;
        document.getElementById('hp-text').innerText = Math.floor(player.hp);
        document.getElementById('kill-text').innerText = player.kills;
    }

    function gameOver() {
        gameState = 'gameover';
        document.getElementById('game-over').classList.remove('hidden');
        document.getElementById('end-stats').innerText = `LEVEL: ${player.level} | KILLS: ${player.kills}`;
    }

</script>
</body>
</html>
