<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>è‚‰é¸½é‡åˆ¶ç‰ˆ - åŠ¨èµ·æ¥çš„ç²¾çµå›¾ï¼</title>
    <style>
        body {
            margin: 0; overflow: hidden; background-color: #0a0a0a;
            font-family: 'Microsoft YaHei', sans-serif; color: white; user-select: none;
        }
        canvas { display: block; }
        /* UI CSS ä¿æŒä¸å˜ï¼Œä¸ºäº†èŠ‚çœç¯‡å¹…çœç•¥ï¼Œè¯·ä½¿ç”¨ä¸Šä¸€ä¸ªç‰ˆæœ¬çš„CSS */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        #hud-top { position: absolute; top: 20px; width: 100%; display: flex; flex-direction: column; align-items: center; }
        #exp-bar-container { width: 60%; height: 15px; background: #222; border-radius: 10px; border: 2px solid #444; overflow: hidden; }
        #exp-bar { width: 0%; height: 100%; background: linear-gradient(90deg, #00f260, #0575e6); border-radius: 8px; transition: width 0.3s ease-out; }
        #level-display { margin-top: 10px; font-size: 20px; font-weight: 800; text-shadow: 0px 0px 8px rgba(0, 242, 96, 0.7); }
        #boss-warning { display: none; color: red; font-size: 32px; font-weight: bold; margin-top: 20px; animation: pulse 1s infinite alternate; }
        @keyframes pulse { from { opacity: 0.6; transform: scale(0.95); } to { opacity: 1; transform: scale(1.05); } }
        #upgrade-menu { pointer-events: auto; display: none; background: rgba(15, 15, 20, 0.95); padding: 40px; border-radius: 25px; flex-direction: column; align-items: center; border: 1px solid rgba(255,255,255,0.1); backdrop-filter: blur(10px); }
        .cards-container { display: flex; gap: 25px; }
        .card { background: linear-gradient(145deg, #2a2a35, #1c1c24); border: 3px solid #444; width: 160px; height: 220px; padding: 20px; border-radius: 15px; cursor: pointer; transition: all 0.3s; display: flex; flex-direction: column; align-items: center; text-align: center; position: relative; overflow: hidden; }
        .card:hover { transform: translateY(-10px) scale(1.05); border-color: #00c6ff; }
        .card-icon { font-size: 48px; margin-bottom: 15px; }
        .card-title { font-weight: 800; margin-bottom: 12px; color: #fff; font-size: 18px;}
        .card-desc { font-size: 13px; color: #bbb; line-height: 1.4; }
        #game-over { pointer-events: auto; display: none; background: rgba(20,0,0,0.9); padding: 50px; text-align: center; border-radius: 15px; border: 2px solid red; }
        button { padding: 12px 24px; font-size: 18px; font-weight: bold; background: linear-gradient(to bottom, #ff4b4b, #cc0000); color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 20px; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui-layer">
        <div id="hud-top">
            <div id="exp-bar-container"><div id="exp-bar"></div></div>
            <div id="level-display">Level 1</div>
            <div id="boss-warning">WARNING: BOSS INCOMING!</div>
        </div>
        <div id="upgrade-menu">
            <h2>èƒ½é‡æ¿€å¢ï¼é€‰æ‹©å¼ºåŒ–è·¯çº¿</h2>
            <div class="cards-container" id="cards-container"></div>
        </div>
        <div id="game-over">
            <h1 style="color: #ff3333;">å­˜æ´»ç»ˆæ­¢</h1>
            <p id="final-stats">...</p>
            <button onclick="location.reload()">å†æ¬¡æŒ‘æˆ˜</button>
        </div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize); resize();

    // --- ä¿®æ”¹ï¼šåŠ è½½ç²¾çµå›¾è¡¨ (Spritesheet) ---
    // è¿™é‡Œä½¿ç”¨ä¸€ä¸ªæ ‡å‡†çš„ 4å¸§æ¨ªå‘æ’åˆ—çš„ç²¾çµå›¾ä½œä¸ºç¤ºä¾‹
    // å¦‚æœè¦ç”¨ä½ è‡ªå·±çš„è§’è‰²ï¼Œéœ€è¦æŠŠGIFè½¬æ¢æˆè¿™ç§æ¨ªç€æ’åˆ—çš„å›¾
    const playerSprite = new Image();
    // è¿™æ˜¯ä¸€ä¸ªç¤ºä¾‹å›¾é“¾æ¥ï¼Œç¡®ä¿ä½ çš„ç½‘ç»œèƒ½è®¿é—®å®ƒ
    playerSprite.src = 'https://i.imgur.com/16c0V5r.png'; 

    // æ¸¸æˆåŸºç¡€å˜é‡
    let gameState = 'playing'; let frame = 0; let startTime = Date.now(); let bossActive = false;
    const keys = {};
    window.addEventListener('keydown', e => keys[e.key] = true);
    window.addEventListener('keyup', e => keys[e.key] = false);

    // --- Player ç±» (æ ¸å¿ƒä¿®æ”¹) ---
    class Player {
        constructor() {
            this.x = canvas.width / 2; this.y = canvas.height / 2;
            this.radius = 20; 
            // ç»˜åˆ¶åˆ°å±å¹•ä¸Šçš„å¤§å° (å¯ä»¥æ¯”å®é™…ç´ æå¤§)
            this.drawSize = 64; 
            
            // --- åŠ¨ç”»ç›¸å…³å±æ€§ ---
            this.spriteCols = 4; // è¿™å¼ ç²¾çµå›¾æ¨ªå‘æœ‰4åˆ—(4å¸§)
            this.currentFrame = 0; // å½“å‰æ’­æ”¾åˆ°ç¬¬å‡ å¸§ (0, 1, 2, 3)
            this.animTimer = 0;    // åŠ¨ç”»è®¡æ—¶å™¨
            this.animSpeed = 10;   // åŠ¨ç”»é€Ÿåº¦ï¼šæ¯éš”å¤šå°‘ä¸ªæ¸¸æˆå¸§åˆ‡æ¢ä¸€æ¬¡å›¾ç‰‡(æ•°å­—è¶Šå¤§è¶Šæ…¢)
            this.isMoving = false; // æ˜¯å¦åœ¨ç§»åŠ¨

            // åŸºç¡€å±æ€§
            this.speed = 4; this.hp = 100; this.maxHp = 100;
            this.level = 1; this.exp = 0; this.expToNextLevel = 15;
            // æˆ˜æ–—å±æ€§
            this.damage = 10; this.projectileSpeed = 8; this.fireRate = 35; 
            this.lastShot = 0; this.projectileCount = 1; this.penetration = 0;
            this.skillLevels = { dmg: 0, pierce: 0, speed: 0, multishot: 0 };
            this.projSize = 5; this.projColor = '#ffff00';
        }

        update() {
            let dx = 0, dy = 0;
            if (keys['w'] || keys['ArrowUp']) dy -= 1;
            if (keys['s'] || keys['ArrowDown']) dy += 1;
            if (keys['a'] || keys['ArrowLeft']) dx -= 1;
            if (keys['d'] || keys['ArrowRight']) dx += 1;
            
            // åˆ¤æ–­æ˜¯å¦åœ¨ç§»åŠ¨
            this.isMoving = (dx !== 0 || dy !== 0);

            const length = Math.hypot(dx, dy);
            if (length > 0) {
                dx /= length; dy /= length;
                this.x += dx * this.speed;
                this.y += dy * this.speed;
            }
            this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
            this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));

            if (frame - this.lastShot > this.fireRate) {
                const target = this.findNearestEnemy();
                if (target) { this.shoot(target); this.lastShot = frame; }
            }

            // --- åŠ¨ç”»å¸§æ›´æ–°é€»è¾‘ ---
            if (this.isMoving) {
                this.animTimer++;
                // è®¡æ—¶å™¨è¶…è¿‡é€Ÿåº¦é˜ˆå€¼ï¼Œåˆ‡æ¢åˆ°ä¸‹ä¸€å¸§
                if (this.animTimer > this.animSpeed) {
                    this.animTimer = 0;
                    this.currentFrame++;
                    // å¦‚æœè¶…è¿‡äº†æ€»å¸§æ•°ï¼Œå›åˆ°ç¬¬0å¸§å®ç°å¾ªç¯
                    if (this.currentFrame >= this.spriteCols) {
                        this.currentFrame = 0;
                    }
                }
            } else {
                // å¦‚æœç«™ç€ä¸åŠ¨ï¼Œé‡ç½®ä¸ºç¬¬1å¸§ (çœ‹èµ·æ¥åƒç«™ç«‹å§¿åŠ¿)
                this.currentFrame = 0;
                this.animTimer = 0;
            }
        }

        draw() {
            // ç¡®ä¿å›¾ç‰‡åŠ è½½å®Œæˆ
            if (playerSprite.complete && playerSprite.naturalWidth > 0) {
                // 1. è®¡ç®—å•ä¸ªå¸§çš„å®½åº¦å’Œé«˜åº¦
                // å‡è®¾åŸå›¾æ˜¯æ¨ªç€æ’åˆ—çš„å•è¡Œ
                const frameWidth = playerSprite.width / this.spriteCols;
                const frameHeight = playerSprite.height;

                // 2. è®¡ç®—ä»ç´ æå›¾çš„å“ªä¸ªä½ç½®å¼€å§‹â€œåˆ‡â€
                // æºXåæ ‡ = å½“å‰å¸§ç´¢å¼• * å•å¸§å®½åº¦
                const sourceX = this.currentFrame * frameWidth;
                const sourceY = 0; // å› ä¸ºåªæœ‰ä¸€è¡Œï¼ŒYæ°¸è¿œæ˜¯0

                // 3. ä½¿ç”¨å¤æ‚çš„ drawImage æ–¹æ³•è¿›è¡Œåˆ‡å‰²ç»˜åˆ¶
                // ctx.drawImage(å›¾ç‰‡æº, åˆ‡å‰²èµ·ç‚¹X, åˆ‡å‰²èµ·ç‚¹Y, åˆ‡å¤šå®½, åˆ‡å¤šé«˜, æ”¾åˆ°å±å¹•X, æ”¾åˆ°å±å¹•Y, æ”¾å¤šå®½, æ”¾å¤šé«˜)
                ctx.drawImage(
                    playerSprite, 
                    sourceX, sourceY,       // Source X, Y (ç´ æåˆ‡å‰²ç‚¹)
                    frameWidth, frameHeight, // Source W, H (åˆ‡å‰²å¤§å°)
                    this.x - this.drawSize / 2, // Dest X (å±å¹•ä½ç½®éœ€å±…ä¸­)
                    this.y - this.drawSize / 2, // Dest Y
                    this.drawSize, this.drawSize // Dest W, H (å±å¹•æ˜¾ç¤ºå¤§å°)
                );

            } else {
                // å›¾ç‰‡æœªåŠ è½½æ—¶çš„å¤‡ç”¨æ˜¾ç¤º
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#00c6ff'; ctx.fill();
            }
            
            // è¡€æ¡ (ä¿æŒä¸å˜)
            const hpBarWidth = 50; const hpPercent = this.hp / this.maxHp;
            ctx.fillStyle = '#330000'; ctx.fillRect(this.x - hpBarWidth/2, this.y + 35, hpBarWidth, 6);
            ctx.fillStyle = hpPercent > 0.5 ? '#00ff00' : (hpPercent > 0.2 ? '#ffff00' : '#ff0000');
            ctx.fillRect(this.x - hpBarWidth/2, this.y + 35, hpBarWidth * hpPercent, 6);
        }

        // ... (findNearestEnemy, shoot, gainExp, levelUp, updateVisuals æ–¹æ³•ä¿æŒä¸å˜ï¼Œçœç•¥ä»¥èŠ‚çœç©ºé—´) ...
        findNearestEnemy() {
            let nearest = null; let minDist = Infinity;
            enemies.forEach(enemy => { const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y); if (dist < minDist) { minDist = dist; nearest = enemy; } });
            return nearest;
        }
        shoot(target) {
            const angle = Math.atan2(target.y - this.y, target.x - this.x); const spread = 0.15;
            const startAngle = angle - (spread * (this.projectileCount - 1)) / 2;
            createExplosion(this.x + Math.cos(angle) * 20, this.y + Math.sin(angle) * 20, this.projColor, 8, 2, 15);
            for (let i = 0; i < this.projectileCount; i++) {
                const currentAngle = startAngle + i * spread;
                const velocity = { x: Math.cos(currentAngle) * this.projectileSpeed, y: Math.sin(currentAngle) * this.projectileSpeed };
                projectiles.push(new Projectile(this.x, this.y, velocity, this.damage, this.penetration, this.projSize, this.projColor));
            }
        }
        gainExp(amount) { this.exp += amount; if (this.exp >= this.expToNextLevel) this.levelUp(); updateUI(); }
        levelUp() { this.level++; this.exp -= this.expToNextLevel; this.expToNextLevel = Math.floor(this.expToNextLevel * 1.4); if (this.level % 5 === 0) triggerBossFight(); showUpgradeMenu(); }
        updateVisuals() { this.projSize = 5 + this.skillLevels.dmg * 0.8; const red = Math.min(255, 200 + this.skillLevels.dmg * 15); const green = Math.max(100, 255 - this.skillLevels.dmg * 20); this.projColor = `rgb(${red}, ${green}, 0)`; if (this.skillLevels.pierce > 0) { this.projColor = '#00ffff'; this.projSize = 4 + this.skillLevels.dmg * 0.5; } }
    }

    // --- å…¶ä»–ç±»å’Œå‡½æ•°ä¿æŒä¸å˜ (EnemyBase, Enemy, Boss, Projectile, ExpOrb, Particle, etc.) ---
    // ä¸ºäº†ä»£ç ç®€æ´ï¼Œè¿™é‡Œçœç•¥äº†è¿™äº›ç±»çš„å®šä¹‰ï¼Œè¯·å¤åˆ¶ä¸Šä¸€ç‰ˆä»£ç ä¸­é™¤äº† Player ç±»ä»¥å¤–çš„æ‰€æœ‰å†…å®¹åˆ°è¿™é‡Œã€‚
    // å®ƒä»¬ä¸éœ€è¦ä»»ä½•ä¿®æ”¹å°±èƒ½é…åˆæ–°çš„åŠ¨ç”» Player å·¥ä½œã€‚
    
    // (ä¸ºæ–¹ä¾¿ç›´æ¥è¿è¡Œï¼Œæˆ‘è¿™é‡Œè¿˜æ˜¯æŠŠå®ƒä»¬æ”¾è¿›æ¥ï¼Œå®é™…å¼€å‘ä¸­å¯ä»¥åˆ†æ–‡ä»¶)
    class EnemyBase {
        constructor(x, y, radius, color, hp, speed, expValue) { this.x = x; this.y = y; this.radius = radius; this.color = color; this.hp = hp; this.maxHp = hp; this.speed = speed; this.expValue = expValue; }
        update() { const angle = Math.atan2(player.y - this.y, player.x - this.x); this.x += Math.cos(angle) * this.speed; this.y += Math.sin(angle) * this.speed; this.checkCollisionWithPlayer(); }
        checkCollisionWithPlayer() { const dist = Math.hypot(this.x - player.x, this.y - player.y); if (dist < this.radius + player.radius) { player.hp -= (this instanceof Boss ? 30 : 10); updateUI(); if (!(this instanceof Boss)) this.hp = 0; createExplosion(this.x, this.y, 'red', 20, 5); if (player.hp <= 0) endGame(); } }
        draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fillStyle = this.color; ctx.fill(); if (this.hp < this.maxHp) { ctx.fillStyle = 'red'; ctx.fillRect(this.x-this.radius, this.y-this.radius-10, this.radius*2, 4); ctx.fillStyle = '#0f0'; ctx.fillRect(this.x-this.radius, this.y-this.radius-10, this.radius*2 * (this.hp/this.maxHp), 4); } }
    }
    class Enemy extends EnemyBase {
        constructor() { const spawnPos = getSpawnPosition(); const hp = 25 + (player.level * 8); const speed = 0.7 + Math.random() * 0.6 + (player.level * 0.02); super(spawnPos.x, spawnPos.y, 12, '#ff4444', hp, speed, 8 + player.level); }
    }
    class Boss extends EnemyBase {
        constructor() { const spawnPos = getSpawnPosition(true); const hp = 800 + (player.level * 150); super(spawnPos.x, spawnPos.y, 40, '#8a00ff', hp, 1.2, 300); this.isBoss = true; }
        draw() { ctx.save(); ctx.shadowColor = this.color; ctx.shadowBlur = 30; super.draw(); ctx.restore(); ctx.beginPath(); ctx.arc(this.x, this.y, this.radius * 0.6, 0, Math.PI*2); ctx.fillStyle = '#aa33ff'; ctx.fill(); }
    }
    function getSpawnPosition(forceOuter = false) { let x, y; const margin = forceOuter ? 100 : 30; if (Math.random() < 0.5) { x = Math.random() < 0.5 ? -margin : canvas.width + margin; y = Math.random() * canvas.height; } else { x = Math.random() * canvas.width; y = Math.random() < 0.5 ? -margin : canvas.height + margin; } return {x, y}; }
    class Projectile {
        constructor(x, y, velocity, damage, penetration, size, color) { this.x = x; this.y = y; this.velocity = velocity; this.damage = damage; this.penetration = penetration; this.radius = size; this.color = color; this.hitList = []; this.hasTrail = penetration > 0; }
        update() { this.x += this.velocity.x; this.y += this.velocity.y; if (this.hasTrail && frame % 3 === 0) createExplosion(this.x, this.y, this.color, 3, 1, 5); }
        draw() { ctx.save(); ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fillStyle = this.color; ctx.shadowColor = this.color; ctx.shadowBlur = 15; ctx.fill(); ctx.restore(); }
    }
    class ExpOrb {
        constructor(x, y, value) { this.x = x; this.y = y; this.value = value; this.radius = 6; this.color = value > 100 ? '#ffcc00' : '#00ffaa'; }
        update() { const dist = Math.hypot(this.x - player.x, this.y - player.y); const attractRange = 120 + player.level * 2; if (dist < attractRange) { const pullStrength = (1 - dist / attractRange) * 8; this.x += (player.x - this.x) * 0.05 * pullStrength; this.y += (player.y - this.y) * 0.05 * pullStrength; } if (dist < player.radius + this.radius) { player.gainExp(this.value); this.markedForDeletion = true; } }
        draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fillStyle = this.color; ctx.shadowColor = this.color; ctx.shadowBlur = 10; ctx.fill(); ctx.shadowBlur = 0; }
    }
    class Particle {
        constructor(x, y, color, speedMult, size) { this.x = x; this.y = y; this.color = color; const angle = Math.random() * Math.PI * 2; const speed = Math.random() * speedMult; this.velocity = { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed }; this.alpha = 1; this.decay = 0.03 + Math.random() * 0.03; this.size = size || (2 + Math.random() * 3); }
        update() { this.x += this.velocity.x; this.y += this.velocity.y; this.alpha -= this.decay; }
        draw() { ctx.save(); ctx.globalAlpha = this.alpha; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill(); ctx.restore(); }
    }

    let player = new Player();
    let enemies = []; let projectiles = []; let expOrbs = []; let particles = [];
    function spawnEnemy() { if (bossActive) return; enemies.push(new Enemy()); }
    function triggerBossFight() { bossActive = true; document.getElementById('boss-warning').style.display = 'block'; enemies = enemies.filter(e => Math.hypot(e.x - player.x, e.y - player.y) < canvas.width/2); setTimeout(() => { enemies.push(new Boss()); document.getElementById('boss-warning').style.display = 'none'; }, 2000); }
    function createExplosion(x, y, color, count = 10, speed = 5, size = 0) { for (let i = 0; i < count; i++) { particles.push(new Particle(x, y, color, speed, size)); } }
    
    // ä¸»å¾ªç¯
    function animate() {
        if (gameState !== 'playing') return;
        requestAnimationFrame(animate);
        ctx.fillStyle = 'rgba(10, 10, 10, 0.4)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        frame++;
        let spawnRate = Math.max(15, 50 - player.level * 1.5); 
        if (frame % Math.floor(spawnRate) === 0) spawnEnemy();
        player.update(); player.draw();
        projectiles.forEach((p, index) => { p.update(); p.draw(); if (p.x < -50 || p.x > canvas.width+50 || p.y < -50 || p.y > canvas.height+50) { projectiles.splice(index, 1); return; } for (let i = enemies.length - 1; i >= 0; i--) { const enemy = enemies[i]; const dist = Math.hypot(p.x - enemy.x, p.y - enemy.y); if (dist < enemy.radius + p.radius && !p.hitList.includes(enemy)) { enemy.hp -= p.damage; p.hitList.push(enemy); createExplosion(p.x, p.y, '#ffaa00', 5, 4, 2); if (enemy.hp <= 0) { createExplosion(enemy.x, enemy.y, enemy.color, enemy instanceof Boss ? 50 : 15, enemy instanceof Boss ? 10 : 6); expOrbs.push(new ExpOrb(enemy.x, enemy.y, enemy.expValue)); enemies.splice(i, 1); if (enemy instanceof Boss) bossActive = false; } if (p.penetration > 0) p.penetration--; else { projectiles.splice(index, 1); break; } } } });
        enemies.forEach(e => { e.update(); e.draw(); }); expOrbs.forEach((o, i) => { o.update(); o.draw(); if(o.markedForDeletion) expOrbs.splice(i, 1); }); particles.forEach((p, i) => { p.update(); p.draw(); if(p.alpha <= 0) particles.splice(i, 1); });
    }

    // æŠ€èƒ½å’ŒUIç›¸å…³å‡½æ•°ä¿æŒä¸å˜
    const skillPool = [ { id: 'multishot', name: 'åˆ†è£‚ç®­çŸ¢', desc: 'é¢å¤–å‘å°„ä¸€æšå­å¼¹', icon: 'ğŸ¹', color: '#00c6ff', effect: () => { player.projectileCount++; player.skillLevels.multishot++; } }, { id: 'dmg_up', name: 'ç†”å²©å¼¹è¯', desc: 'ä¼¤å®³+15ï¼Œå­å¼¹å˜å¤§å˜çº¢', icon: 'ğŸ’¥', color: '#ff4b4b', effect: () => { player.damage += 15; player.skillLevels.dmg++; } }, { id: 'speed_up', name: 'è¿…æ·æ­¥ä¼', desc: 'ç§»åŠ¨é€Ÿåº¦ +1.5', icon: 'ğŸ‘Ÿ', color: '#ffd700', effect: () => { player.speed += 1.5; player.skillLevels.speed++; } }, { id: 'haste', name: 'ç‹‚çƒ­å°„å‡»', desc: 'æ”»é€Ÿæ˜¾è‘—æå‡ (18%)', icon: 'ğŸ”¥', color: '#ff8800', effect: () => { player.fireRate = Math.max(4, player.fireRate * 0.82); } }, { id: 'heal', name: 'æ³°å¦ä¹‹å¿ƒ', desc: 'ç”Ÿå‘½å…¨æ»¡ï¼Œä¸Šé™+40', icon: 'ğŸ’–', color: '#ff00cc', effect: () => { player.maxHp += 40; player.hp = player.maxHp; } }, { id: 'pierce', name: 'ç­‰ç¦»å­ç©¿é€', desc: 'å­å¼¹è·å¾—ç©¿é€èƒ½åŠ›ï¼Œå˜ä¸ºé’è‰²', icon: 'âš¡', color: '#00ffff', effect: () => { player.penetration++; player.skillLevels.pierce++; } } ];
    function showUpgradeMenu() { gameState = 'paused'; const container = document.getElementById('cards-container'); container.innerHTML = ''; const shuffled = [...skillPool]; for (let i = shuffled.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]; } const choices = shuffled.slice(0, 3); choices.forEach(skill => { const card = document.createElement('div'); card.className = 'card'; card.style.borderColor = skill.color; card.style.color = skill.color; card.innerHTML = ` <div class="card-icon" style="text-shadow: 0 0 20px ${skill.color}">${skill.icon}</div> <div class="card-title" style="color: ${skill.color}">${skill.name}</div> <div class="card-desc">${skill.desc}</div> `; card.onclick = () => { skill.effect(); player.updateVisuals(); document.getElementById('upgrade-menu').style.display = 'none'; gameState = 'playing'; animate(); }; container.appendChild(card); }); document.getElementById('upgrade-menu').style.display = 'flex'; }
    function updateUI() { const bar = document.getElementById('exp-bar'); const pct = Math.min(100, (player.exp / player.expToNextLevel) * 100); bar.style.width = pct + '%'; document.getElementById('level-display').innerText = `Level ${player.level}`; }
    function endGame() { gameState = 'gameover'; document.getElementById('game-over').style.display = 'block'; const time = ((Date.now() - startTime) / 1000).toFixed(0); document.getElementById('final-stats').innerHTML = ` å­˜æ´»æ—¶é—´: <span style="color:#00c6ff">${time}s</span><br> æœ€ç»ˆç­‰çº§: <span style="color:#ffd700">Lv.${player.level}</span> `; }

    animate();
</script>
</body>
</html>
